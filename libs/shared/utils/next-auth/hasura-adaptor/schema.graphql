schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  refresh the cache entry
  """
  refresh: Boolean! = false

  """
  measured in seconds
  """
  ttl: Int! = 60
) on QUERY

"""
columns and relationships of "account"
"""
type Account {
  accessToken: String
  expiresAt: bigint
  id: uuid!
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String!
  providerAccountId: String!
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String!

  """
  An object relationship
  """
  user: User!
  userId: uuid!
}

"""
aggregated selection of "account"
"""
type AccountAggregate {
  aggregate: AccountAggregateFields
  nodes: [Account!]!
}

"""
aggregate fields of "account"
"""
type AccountAggregateFields {
  avg: AccountAvgFields
  count(columns: [AccountSelectColumn!], distinct: Boolean): Int!
  max: AccountMaxFields
  min: AccountMinFields
  stddev: AccountStddevFields
  stddevPop: AccountStddev_popFields
  stddevSamp: AccountStddev_sampFields
  sum: AccountSumFields
  varPop: AccountVar_popFields
  varSamp: AccountVar_sampFields
  variance: AccountVarianceFields
}

"""
order by aggregate values of table "account"
"""
input AccountAggregateOrderBy {
  avg: account_avg_order_by
  count: OrderBy
  max: account_max_order_by
  min: account_min_order_by
  stddev: account_stddev_order_by
  stddev_pop: account_stddev_pop_order_by
  stddev_samp: account_stddev_samp_order_by
  sum: account_sum_order_by
  var_pop: account_var_pop_order_by
  var_samp: account_var_samp_order_by
  variance: account_variance_order_by
}

"""
input type for inserting array relation for remote table "account"
"""
input AccountArrRelInsertInput {
  data: [AccountInsertInput!]!

  """
  upsert condition
  """
  onConflict: AccountOnConflict
}

"""
aggregate avg on columns
"""
type AccountAvgFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
"""
input AccountBoolExp {
  _and: [AccountBoolExp!]
  _not: AccountBoolExp
  _or: [AccountBoolExp!]
  accessToken: StringComparisonExp
  expiresAt: BigintComparisonExp
  id: UuidComparisonExp
  idToken: StringComparisonExp
  oauthToken: StringComparisonExp
  oauthTokenSecret: StringComparisonExp
  provider: StringComparisonExp
  providerAccountId: StringComparisonExp
  refreshToken: StringComparisonExp
  refreshTokenExpiresIn: BigintComparisonExp
  scope: StringComparisonExp
  sessionState: StringComparisonExp
  tokenType: StringComparisonExp
  type: StringComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "account"
"""
enum AccountConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  account_pkey
}

"""
input type for incrementing numeric columns in table "account"
"""
input AccountIncInput {
  expiresAt: bigint
  refreshTokenExpiresIn: bigint
}

"""
input type for inserting data into table "account"
"""
input AccountInsertInput {
  accessToken: String
  expiresAt: bigint
  id: uuid
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String
  providerAccountId: String
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String
  user: UserObjRelInsertInput
  userId: uuid
}

"""
aggregate max on columns
"""
type AccountMaxFields {
  accessToken: String
  expiresAt: bigint
  id: uuid
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String
  providerAccountId: String
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String
  userId: uuid
}

"""
aggregate min on columns
"""
type AccountMinFields {
  accessToken: String
  expiresAt: bigint
  id: uuid
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String
  providerAccountId: String
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String
  userId: uuid
}

"""
response of any mutation on the table "account"
"""
type AccountMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Account!]!
}

"""
on_conflict condition type for table "account"
"""
input AccountOnConflict {
  constraint: AccountConstraint!
  update_columns: [AccountUpdateColumn!]! = []
  where: AccountBoolExp
}

"""
Ordering options when selecting data from "account".
"""
input AccountOrderBy {
  accessToken: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  idToken: OrderBy
  oauthToken: OrderBy
  oauthTokenSecret: OrderBy
  provider: OrderBy
  providerAccountId: OrderBy
  refreshToken: OrderBy
  refreshTokenExpiresIn: OrderBy
  scope: OrderBy
  sessionState: OrderBy
  tokenType: OrderBy
  type: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""
primary key columns input for table: account
"""
input AccountPkColumnsInput {
  id: uuid!
}

"""
select columns of table "account"
"""
enum AccountSelectColumn {
  """
  column name
  """
  accessToken

  """
  column name
  """
  expiresAt

  """
  column name
  """
  id

  """
  column name
  """
  idToken

  """
  column name
  """
  oauthToken

  """
  column name
  """
  oauthTokenSecret

  """
  column name
  """
  provider

  """
  column name
  """
  providerAccountId

  """
  column name
  """
  refreshToken

  """
  column name
  """
  refreshTokenExpiresIn

  """
  column name
  """
  scope

  """
  column name
  """
  sessionState

  """
  column name
  """
  tokenType

  """
  column name
  """
  type

  """
  column name
  """
  userId
}

"""
input type for updating data in table "account"
"""
input AccountSetInput {
  accessToken: String
  expiresAt: bigint
  id: uuid
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String
  providerAccountId: String
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String
  userId: uuid
}

"""
aggregate stddev on columns
"""
type AccountStddevFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
aggregate stddev_pop on columns
"""
type AccountStddev_popFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
aggregate stddev_samp on columns
"""
type AccountStddev_sampFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
aggregate sum on columns
"""
type AccountSumFields {
  expiresAt: bigint
  refreshTokenExpiresIn: bigint
}

"""
update columns of table "account"
"""
enum AccountUpdateColumn {
  """
  column name
  """
  accessToken

  """
  column name
  """
  expiresAt

  """
  column name
  """
  id

  """
  column name
  """
  idToken

  """
  column name
  """
  oauthToken

  """
  column name
  """
  oauthTokenSecret

  """
  column name
  """
  provider

  """
  column name
  """
  providerAccountId

  """
  column name
  """
  refreshToken

  """
  column name
  """
  refreshTokenExpiresIn

  """
  column name
  """
  scope

  """
  column name
  """
  sessionState

  """
  column name
  """
  tokenType

  """
  column name
  """
  type

  """
  column name
  """
  userId
}

input AccountUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: AccountIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: AccountSetInput
  where: AccountBoolExp!
}

"""
aggregate var_pop on columns
"""
type AccountVar_popFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
aggregate var_samp on columns
"""
type AccountVar_sampFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
aggregate variance on columns
"""
type AccountVarianceFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
columns and relationships of "allowed_role"
"""
type AllowedRole {
  role: RolesEnum!

  """
  An object relationship
  """
  user: User!
  userId: uuid!
}

"""
aggregated selection of "allowed_role"
"""
type AllowedRoleAggregate {
  aggregate: AllowedRoleAggregateFields
  nodes: [AllowedRole!]!
}

"""
aggregate fields of "allowed_role"
"""
type AllowedRoleAggregateFields {
  count(columns: [AllowedRoleSelectColumn!], distinct: Boolean): Int!
  max: AllowedRoleMaxFields
  min: AllowedRoleMinFields
}

"""
order by aggregate values of table "allowed_role"
"""
input AllowedRoleAggregateOrderBy {
  count: OrderBy
  max: allowed_role_max_order_by
  min: allowed_role_min_order_by
}

"""
input type for inserting array relation for remote table "allowed_role"
"""
input AllowedRoleArrRelInsertInput {
  data: [AllowedRoleInsertInput!]!

  """
  upsert condition
  """
  onConflict: AllowedRoleOnConflict
}

"""
Boolean expression to filter rows from the table "allowed_role". All fields are combined with a logical 'AND'.
"""
input AllowedRoleBoolExp {
  _and: [AllowedRoleBoolExp!]
  _not: AllowedRoleBoolExp
  _or: [AllowedRoleBoolExp!]
  role: RolesEnumComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "allowed_role"
"""
enum AllowedRoleConstraint {
  """
  unique or primary key constraint on columns "user_id", "role"
  """
  allowed_role_pkey
}

"""
input type for inserting data into table "allowed_role"
"""
input AllowedRoleInsertInput {
  role: RolesEnum
  user: UserObjRelInsertInput
  userId: uuid
}

"""
aggregate max on columns
"""
type AllowedRoleMaxFields {
  userId: uuid
}

"""
aggregate min on columns
"""
type AllowedRoleMinFields {
  userId: uuid
}

"""
response of any mutation on the table "allowed_role"
"""
type AllowedRoleMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [AllowedRole!]!
}

"""
on_conflict condition type for table "allowed_role"
"""
input AllowedRoleOnConflict {
  constraint: AllowedRoleConstraint!
  update_columns: [AllowedRoleUpdateColumn!]! = []
  where: AllowedRoleBoolExp
}

"""
Ordering options when selecting data from "allowed_role".
"""
input AllowedRoleOrderBy {
  role: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""
primary key columns input for table: allowed_role
"""
input AllowedRolePkColumnsInput {
  role: RolesEnum!
  userId: uuid!
}

"""
select columns of table "allowed_role"
"""
enum AllowedRoleSelectColumn {
  """
  column name
  """
  role

  """
  column name
  """
  userId
}

"""
input type for updating data in table "allowed_role"
"""
input AllowedRoleSetInput {
  role: RolesEnum
  userId: uuid
}

"""
update columns of table "allowed_role"
"""
enum AllowedRoleUpdateColumn {
  """
  column name
  """
  role

  """
  column name
  """
  userId
}

input AllowedRoleUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: AllowedRoleSetInput
  where: AllowedRoleBoolExp!
}

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input BigintComparisonExp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _isNull: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
ordering argument of a cursor
"""
enum CursorOrdering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
column ordering options
"""
enum OrderBy {
  """
  in ascending order, nulls last
  """
  ASC

  """
  in ascending order, nulls first
  """
  ASC_NULLS_FIRST

  """
  in ascending order, nulls last
  """
  ASC_NULLS_LAST

  """
  in descending order, nulls first
  """
  DESC

  """
  in descending order, nulls first
  """
  DESC_NULLS_FIRST

  """
  in descending order, nulls last
  """
  DESC_NULLS_LAST
}

"""
columns and relationships of "roles"
"""
type Roles {
  """
  An array relationship
  """
  allowedRoles(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): [AllowedRole!]!

  """
  An aggregate relationship
  """
  allowedRolesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): AllowedRoleAggregate!
  description: String

  """
  An array relationship
  """
  users(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): [User!]!

  """
  An aggregate relationship
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): UserAggregate!
  value: String!
}

"""
aggregated selection of "roles"
"""
type RolesAggregate {
  aggregate: RolesAggregateFields
  nodes: [Roles!]!
}

"""
aggregate fields of "roles"
"""
type RolesAggregateFields {
  count(columns: [RolesSelectColumn!], distinct: Boolean): Int!
  max: RolesMaxFields
  min: RolesMinFields
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input RolesBoolExp {
  _and: [RolesBoolExp!]
  _not: RolesBoolExp
  _or: [RolesBoolExp!]
  allowedRoles: AllowedRoleBoolExp
  allowedRoles_aggregate: allowed_role_aggregate_bool_exp
  description: StringComparisonExp
  users: UserBoolExp
  users_aggregate: user_aggregate_bool_exp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "roles"
"""
enum RolesConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  roles_pkey
}

enum RolesEnum {
  USER
}

"""
Boolean expression to compare columns of type "RolesEnum". All fields are combined with logical 'AND'.
"""
input RolesEnumComparisonExp {
  _eq: RolesEnum
  _in: [RolesEnum!]
  _isNull: Boolean
  _neq: RolesEnum
  _nin: [RolesEnum!]
}

"""
input type for inserting data into table "roles"
"""
input RolesInsertInput {
  allowedRoles: AllowedRoleArrRelInsertInput
  description: String
  users: UserArrRelInsertInput
  value: String
}

"""
aggregate max on columns
"""
type RolesMaxFields {
  description: String
  value: String
}

"""
aggregate min on columns
"""
type RolesMinFields {
  description: String
  value: String
}

"""
response of any mutation on the table "roles"
"""
type RolesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input RolesObjRelInsertInput {
  data: RolesInsertInput!

  """
  upsert condition
  """
  onConflict: RolesOnConflict
}

"""
on_conflict condition type for table "roles"
"""
input RolesOnConflict {
  constraint: RolesConstraint!
  update_columns: [RolesUpdateColumn!]! = []
  where: RolesBoolExp
}

"""
Ordering options when selecting data from "roles".
"""
input RolesOrderBy {
  allowedRolesAggregate: AllowedRoleAggregateOrderBy
  description: OrderBy
  usersAggregate: UserAggregateOrderBy
  value: OrderBy
}

"""
primary key columns input for table: roles
"""
input RolesPkColumnsInput {
  value: String!
}

"""
select columns of table "roles"
"""
enum RolesSelectColumn {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "roles"
"""
input RolesSetInput {
  description: String
  value: String
}

"""
update columns of table "roles"
"""
enum RolesUpdateColumn {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

input RolesUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: RolesSetInput
  where: RolesBoolExp!
}

"""
columns and relationships of "session"
"""
type Session {
  expires: timestamptz!
  id: uuid!
  sessionToken: String!

  """
  An object relationship
  """
  user: User!
  userId: uuid!
}

"""
aggregated selection of "session"
"""
type SessionAggregate {
  aggregate: SessionAggregateFields
  nodes: [Session!]!
}

"""
aggregate fields of "session"
"""
type SessionAggregateFields {
  count(columns: [SessionSelectColumn!], distinct: Boolean): Int!
  max: SessionMaxFields
  min: SessionMinFields
}

"""
order by aggregate values of table "session"
"""
input SessionAggregateOrderBy {
  count: OrderBy
  max: session_max_order_by
  min: session_min_order_by
}

"""
input type for inserting array relation for remote table "session"
"""
input SessionArrRelInsertInput {
  data: [SessionInsertInput!]!

  """
  upsert condition
  """
  onConflict: SessionOnConflict
}

"""
Boolean expression to filter rows from the table "session". All fields are combined with a logical 'AND'.
"""
input SessionBoolExp {
  _and: [SessionBoolExp!]
  _not: SessionBoolExp
  _or: [SessionBoolExp!]
  expires: TimestamptzComparisonExp
  id: UuidComparisonExp
  sessionToken: StringComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "session"
"""
enum SessionConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  session_pkey
}

"""
input type for inserting data into table "session"
"""
input SessionInsertInput {
  expires: timestamptz
  id: uuid
  sessionToken: String
  user: UserObjRelInsertInput
  userId: uuid
}

"""
aggregate max on columns
"""
type SessionMaxFields {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
aggregate min on columns
"""
type SessionMinFields {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
response of any mutation on the table "session"
"""
type SessionMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Session!]!
}

"""
on_conflict condition type for table "session"
"""
input SessionOnConflict {
  constraint: SessionConstraint!
  update_columns: [SessionUpdateColumn!]! = []
  where: SessionBoolExp
}

"""
Ordering options when selecting data from "session".
"""
input SessionOrderBy {
  expires: OrderBy
  id: OrderBy
  sessionToken: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""
primary key columns input for table: session
"""
input SessionPkColumnsInput {
  id: uuid!
}

"""
select columns of table "session"
"""
enum SessionSelectColumn {
  """
  column name
  """
  expires

  """
  column name
  """
  id

  """
  column name
  """
  sessionToken

  """
  column name
  """
  userId
}

"""
input type for updating data in table "session"
"""
input SessionSetInput {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
update columns of table "session"
"""
enum SessionUpdateColumn {
  """
  column name
  """
  expires

  """
  column name
  """
  id

  """
  column name
  """
  sessionToken

  """
  column name
  """
  userId
}

input SessionUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: SessionSetInput
  where: SessionBoolExp!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user"
"""
type User {
  """
  An array relationship
  """
  accounts(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): [Account!]!

  """
  An aggregate relationship
  """
  accountsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): AccountAggregate!

  """
  An array relationship
  """
  allowedRoles(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): [AllowedRole!]!

  """
  An aggregate relationship
  """
  allowedRolesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): AllowedRoleAggregate!
  defaultRole: RolesEnum!
  email: String!
  emailVerified: timestamptz
  id: uuid!
  image: String
  name: String

  """
  An object relationship
  """
  role: Roles!

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): [Session!]!

  """
  An aggregate relationship
  """
  sessionsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): SessionAggregate!
}

"""
aggregated selection of "user"
"""
type UserAggregate {
  aggregate: UserAggregateFields
  nodes: [User!]!
}

"""
aggregate fields of "user"
"""
type UserAggregateFields {
  count(columns: [UserSelectColumn!], distinct: Boolean): Int!
  max: UserMaxFields
  min: UserMinFields
}

"""
order by aggregate values of table "user"
"""
input UserAggregateOrderBy {
  count: OrderBy
  max: user_max_order_by
  min: user_min_order_by
}

"""
input type for inserting array relation for remote table "user"
"""
input UserArrRelInsertInput {
  data: [UserInsertInput!]!

  """
  upsert condition
  """
  onConflict: UserOnConflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input UserBoolExp {
  _and: [UserBoolExp!]
  _not: UserBoolExp
  _or: [UserBoolExp!]
  accounts: AccountBoolExp
  accounts_aggregate: account_aggregate_bool_exp
  allowedRoles: AllowedRoleBoolExp
  allowedRoles_aggregate: allowed_role_aggregate_bool_exp
  defaultRole: RolesEnumComparisonExp
  email: StringComparisonExp
  emailVerified: TimestamptzComparisonExp
  id: UuidComparisonExp
  image: StringComparisonExp
  name: StringComparisonExp
  role: RolesBoolExp
  sessions: SessionBoolExp
  sessions_aggregate: session_aggregate_bool_exp
}

"""
unique or primary key constraints on table "user"
"""
enum UserConstraint {
  """
  unique or primary key constraint on columns "email"
  """
  user_email_key

  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}

"""
input type for inserting data into table "user"
"""
input UserInsertInput {
  accounts: AccountArrRelInsertInput
  allowedRoles: AllowedRoleArrRelInsertInput
  defaultRole: RolesEnum
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  role: RolesObjRelInsertInput
  sessions: SessionArrRelInsertInput
}

"""
aggregate max on columns
"""
type UserMaxFields {
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
}

"""
aggregate min on columns
"""
type UserMinFields {
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
}

"""
response of any mutation on the table "user"
"""
type UserMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [User!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input UserObjRelInsertInput {
  data: UserInsertInput!

  """
  upsert condition
  """
  onConflict: UserOnConflict
}

"""
on_conflict condition type for table "user"
"""
input UserOnConflict {
  constraint: UserConstraint!
  update_columns: [UserUpdateColumn!]! = []
  where: UserBoolExp
}

"""
Ordering options when selecting data from "user".
"""
input UserOrderBy {
  accountsAggregate: AccountAggregateOrderBy
  allowedRolesAggregate: AllowedRoleAggregateOrderBy
  defaultRole: OrderBy
  email: OrderBy
  emailVerified: OrderBy
  id: OrderBy
  image: OrderBy
  name: OrderBy
  role: RolesOrderBy
  sessionsAggregate: SessionAggregateOrderBy
}

"""
primary key columns input for table: user
"""
input UserPkColumnsInput {
  id: uuid!
}

"""
select columns of table "user"
"""
enum UserSelectColumn {
  """
  column name
  """
  defaultRole

  """
  column name
  """
  email

  """
  column name
  """
  emailVerified

  """
  column name
  """
  id

  """
  column name
  """
  image

  """
  column name
  """
  name
}

"""
input type for updating data in table "user"
"""
input UserSetInput {
  defaultRole: RolesEnum
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
}

"""
update columns of table "user"
"""
enum UserUpdateColumn {
  """
  column name
  """
  defaultRole

  """
  column name
  """
  email

  """
  column name
  """
  emailVerified

  """
  column name
  """
  id

  """
  column name
  """
  image

  """
  column name
  """
  name
}

input UserUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: UserSetInput
  where: UserBoolExp!
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "verification_token"
"""
type VerificationToken {
  expires: timestamptz!
  identifier: String!
  token: String!
}

"""
aggregated selection of "verification_token"
"""
type VerificationTokenAggregate {
  aggregate: VerificationTokenAggregateFields
  nodes: [VerificationToken!]!
}

"""
aggregate fields of "verification_token"
"""
type VerificationTokenAggregateFields {
  count(columns: [VerificationTokenSelectColumn!], distinct: Boolean): Int!
  max: VerificationTokenMaxFields
  min: VerificationTokenMinFields
}

"""
Boolean expression to filter rows from the table "verification_token". All fields are combined with a logical 'AND'.
"""
input VerificationTokenBoolExp {
  _and: [VerificationTokenBoolExp!]
  _not: VerificationTokenBoolExp
  _or: [VerificationTokenBoolExp!]
  expires: TimestamptzComparisonExp
  identifier: StringComparisonExp
  token: StringComparisonExp
}

"""
unique or primary key constraints on table "verification_token"
"""
enum VerificationTokenConstraint {
  """
  unique or primary key constraint on columns "token"
  """
  verification_token_pkey
}

"""
input type for inserting data into table "verification_token"
"""
input VerificationTokenInsertInput {
  expires: timestamptz
  identifier: String
  token: String
}

"""
aggregate max on columns
"""
type VerificationTokenMaxFields {
  expires: timestamptz
  identifier: String
  token: String
}

"""
aggregate min on columns
"""
type VerificationTokenMinFields {
  expires: timestamptz
  identifier: String
  token: String
}

"""
response of any mutation on the table "verification_token"
"""
type VerificationTokenMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [VerificationToken!]!
}

"""
on_conflict condition type for table "verification_token"
"""
input VerificationTokenOnConflict {
  constraint: VerificationTokenConstraint!
  update_columns: [VerificationTokenUpdateColumn!]! = []
  where: VerificationTokenBoolExp
}

"""
Ordering options when selecting data from "verification_token".
"""
input VerificationTokenOrderBy {
  expires: OrderBy
  identifier: OrderBy
  token: OrderBy
}

"""
primary key columns input for table: verification_token
"""
input VerificationTokenPkColumnsInput {
  token: String!
}

"""
select columns of table "verification_token"
"""
enum VerificationTokenSelectColumn {
  """
  column name
  """
  expires

  """
  column name
  """
  identifier

  """
  column name
  """
  token
}

"""
input type for updating data in table "verification_token"
"""
input VerificationTokenSetInput {
  expires: timestamptz
  identifier: String
  token: String
}

"""
update columns of table "verification_token"
"""
enum VerificationTokenUpdateColumn {
  """
  column name
  """
  expires

  """
  column name
  """
  identifier

  """
  column name
  """
  token
}

input VerificationTokenUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: VerificationTokenSetInput
  where: VerificationTokenBoolExp!
}

input account_aggregate_bool_exp {
  count: account_aggregate_bool_exp_count
}

input account_aggregate_bool_exp_count {
  arguments: [AccountSelectColumn!]
  distinct: Boolean
  filter: AccountBoolExp
  predicate: IntComparisonExp!
}

"""
order by avg() on columns of table "account"
"""
input account_avg_order_by {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
order by max() on columns of table "account"
"""
input account_max_order_by {
  accessToken: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  idToken: OrderBy
  oauthToken: OrderBy
  oauthTokenSecret: OrderBy
  provider: OrderBy
  providerAccountId: OrderBy
  refreshToken: OrderBy
  refreshTokenExpiresIn: OrderBy
  scope: OrderBy
  sessionState: OrderBy
  tokenType: OrderBy
  type: OrderBy
  userId: OrderBy
}

"""
order by min() on columns of table "account"
"""
input account_min_order_by {
  accessToken: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  idToken: OrderBy
  oauthToken: OrderBy
  oauthTokenSecret: OrderBy
  provider: OrderBy
  providerAccountId: OrderBy
  refreshToken: OrderBy
  refreshTokenExpiresIn: OrderBy
  scope: OrderBy
  sessionState: OrderBy
  tokenType: OrderBy
  type: OrderBy
  userId: OrderBy
}

"""
order by stddev() on columns of table "account"
"""
input account_stddev_order_by {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
order by stddev_pop() on columns of table "account"
"""
input account_stddev_pop_order_by {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
order by stddev_samp() on columns of table "account"
"""
input account_stddev_samp_order_by {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
Streaming cursor of the table "account"
"""
input account_streamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: account_streamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input account_streamCursorValueInput {
  accessToken: String
  expiresAt: bigint
  id: uuid
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String
  providerAccountId: String
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String
  userId: uuid
}

"""
order by sum() on columns of table "account"
"""
input account_sum_order_by {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
order by var_pop() on columns of table "account"
"""
input account_var_pop_order_by {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
order by var_samp() on columns of table "account"
"""
input account_var_samp_order_by {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
order by variance() on columns of table "account"
"""
input account_variance_order_by {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

input allowed_role_aggregate_bool_exp {
  count: allowed_role_aggregate_bool_exp_count
}

input allowed_role_aggregate_bool_exp_count {
  arguments: [AllowedRoleSelectColumn!]
  distinct: Boolean
  filter: AllowedRoleBoolExp
  predicate: IntComparisonExp!
}

"""
order by max() on columns of table "allowed_role"
"""
input allowed_role_max_order_by {
  userId: OrderBy
}

"""
order by min() on columns of table "allowed_role"
"""
input allowed_role_min_order_by {
  userId: OrderBy
}

"""
Streaming cursor of the table "allowed_role"
"""
input allowed_role_streamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: allowed_role_streamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input allowed_role_streamCursorValueInput {
  role: RolesEnum
  userId: uuid
}

scalar bigint

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "account"
  """
  deleteAccount(
    """
    filter the rows which have to be deleted
    """
    where: AccountBoolExp!
  ): AccountMutationResponse

  """
  delete single row from the table: "account"
  """
  deleteAccountByPk(id: uuid!): Account

  """
  delete data from the table: "allowed_role"
  """
  deleteAllowedRole(
    """
    filter the rows which have to be deleted
    """
    where: AllowedRoleBoolExp!
  ): AllowedRoleMutationResponse

  """
  delete single row from the table: "allowed_role"
  """
  deleteAllowedRoleByPk(role: RolesEnum!, userId: uuid!): AllowedRole

  """
  delete data from the table: "roles"
  """
  deleteRoles(
    """
    filter the rows which have to be deleted
    """
    where: RolesBoolExp!
  ): RolesMutationResponse

  """
  delete single row from the table: "roles"
  """
  deleteRolesByPk(value: String!): Roles

  """
  delete data from the table: "session"
  """
  deleteSession(
    """
    filter the rows which have to be deleted
    """
    where: SessionBoolExp!
  ): SessionMutationResponse

  """
  delete single row from the table: "session"
  """
  deleteSessionByPk(id: uuid!): Session

  """
  delete data from the table: "user"
  """
  deleteUser(
    """
    filter the rows which have to be deleted
    """
    where: UserBoolExp!
  ): UserMutationResponse

  """
  delete single row from the table: "user"
  """
  deleteUserByPk(id: uuid!): User

  """
  delete data from the table: "verification_token"
  """
  deleteVerificationToken(
    """
    filter the rows which have to be deleted
    """
    where: VerificationTokenBoolExp!
  ): VerificationTokenMutationResponse

  """
  delete single row from the table: "verification_token"
  """
  deleteVerificationTokenByPk(token: String!): VerificationToken

  """
  insert data into the table: "account"
  """
  insertAccount(
    """
    the rows to be inserted
    """
    objects: [AccountInsertInput!]!

    """
    upsert condition
    """
    onConflict: AccountOnConflict
  ): AccountMutationResponse

  """
  insert a single row into the table: "account"
  """
  insertAccountOne(
    """
    the row to be inserted
    """
    object: AccountInsertInput!

    """
    upsert condition
    """
    onConflict: AccountOnConflict
  ): Account

  """
  insert data into the table: "allowed_role"
  """
  insertAllowedRole(
    """
    the rows to be inserted
    """
    objects: [AllowedRoleInsertInput!]!

    """
    upsert condition
    """
    onConflict: AllowedRoleOnConflict
  ): AllowedRoleMutationResponse

  """
  insert a single row into the table: "allowed_role"
  """
  insertAllowedRoleOne(
    """
    the row to be inserted
    """
    object: AllowedRoleInsertInput!

    """
    upsert condition
    """
    onConflict: AllowedRoleOnConflict
  ): AllowedRole

  """
  insert data into the table: "roles"
  """
  insertRoles(
    """
    the rows to be inserted
    """
    objects: [RolesInsertInput!]!

    """
    upsert condition
    """
    onConflict: RolesOnConflict
  ): RolesMutationResponse

  """
  insert a single row into the table: "roles"
  """
  insertRolesOne(
    """
    the row to be inserted
    """
    object: RolesInsertInput!

    """
    upsert condition
    """
    onConflict: RolesOnConflict
  ): Roles

  """
  insert data into the table: "session"
  """
  insertSession(
    """
    the rows to be inserted
    """
    objects: [SessionInsertInput!]!

    """
    upsert condition
    """
    onConflict: SessionOnConflict
  ): SessionMutationResponse

  """
  insert a single row into the table: "session"
  """
  insertSessionOne(
    """
    the row to be inserted
    """
    object: SessionInsertInput!

    """
    upsert condition
    """
    onConflict: SessionOnConflict
  ): Session

  """
  insert data into the table: "user"
  """
  insertUser(
    """
    the rows to be inserted
    """
    objects: [UserInsertInput!]!

    """
    upsert condition
    """
    onConflict: UserOnConflict
  ): UserMutationResponse

  """
  insert a single row into the table: "user"
  """
  insertUserOne(
    """
    the row to be inserted
    """
    object: UserInsertInput!

    """
    upsert condition
    """
    onConflict: UserOnConflict
  ): User

  """
  insert data into the table: "verification_token"
  """
  insertVerificationToken(
    """
    the rows to be inserted
    """
    objects: [VerificationTokenInsertInput!]!

    """
    upsert condition
    """
    onConflict: VerificationTokenOnConflict
  ): VerificationTokenMutationResponse

  """
  insert a single row into the table: "verification_token"
  """
  insertVerificationTokenOne(
    """
    the row to be inserted
    """
    object: VerificationTokenInsertInput!

    """
    upsert condition
    """
    onConflict: VerificationTokenOnConflict
  ): VerificationToken

  """
  update data of the table: "account"
  """
  updateAccount(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: AccountIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: AccountSetInput

    """
    filter the rows which have to be updated
    """
    where: AccountBoolExp!
  ): AccountMutationResponse

  """
  update single row of the table: "account"
  """
  updateAccountByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: AccountIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: AccountSetInput
    pk_columns: AccountPkColumnsInput!
  ): Account

  """
  update multiples rows of table: "account"
  """
  updateAccountMany(
    """
    updates to execute, in order
    """
    updates: [AccountUpdates!]!
  ): [AccountMutationResponse]

  """
  update data of the table: "allowed_role"
  """
  updateAllowedRole(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: AllowedRoleSetInput

    """
    filter the rows which have to be updated
    """
    where: AllowedRoleBoolExp!
  ): AllowedRoleMutationResponse

  """
  update single row of the table: "allowed_role"
  """
  updateAllowedRoleByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: AllowedRoleSetInput
    pk_columns: AllowedRolePkColumnsInput!
  ): AllowedRole

  """
  update multiples rows of table: "allowed_role"
  """
  updateAllowedRoleMany(
    """
    updates to execute, in order
    """
    updates: [AllowedRoleUpdates!]!
  ): [AllowedRoleMutationResponse]

  """
  update data of the table: "roles"
  """
  updateRoles(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: RolesSetInput

    """
    filter the rows which have to be updated
    """
    where: RolesBoolExp!
  ): RolesMutationResponse

  """
  update single row of the table: "roles"
  """
  updateRolesByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: RolesSetInput
    pk_columns: RolesPkColumnsInput!
  ): Roles

  """
  update multiples rows of table: "roles"
  """
  updateRolesMany(
    """
    updates to execute, in order
    """
    updates: [RolesUpdates!]!
  ): [RolesMutationResponse]

  """
  update data of the table: "session"
  """
  updateSession(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: SessionSetInput

    """
    filter the rows which have to be updated
    """
    where: SessionBoolExp!
  ): SessionMutationResponse

  """
  update single row of the table: "session"
  """
  updateSessionByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: SessionSetInput
    pk_columns: SessionPkColumnsInput!
  ): Session

  """
  update multiples rows of table: "session"
  """
  updateSessionMany(
    """
    updates to execute, in order
    """
    updates: [SessionUpdates!]!
  ): [SessionMutationResponse]

  """
  update data of the table: "user"
  """
  updateUser(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: UserSetInput

    """
    filter the rows which have to be updated
    """
    where: UserBoolExp!
  ): UserMutationResponse

  """
  update single row of the table: "user"
  """
  updateUserByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: UserSetInput
    pk_columns: UserPkColumnsInput!
  ): User

  """
  update multiples rows of table: "user"
  """
  updateUserMany(
    """
    updates to execute, in order
    """
    updates: [UserUpdates!]!
  ): [UserMutationResponse]

  """
  update data of the table: "verification_token"
  """
  updateVerificationToken(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: VerificationTokenSetInput

    """
    filter the rows which have to be updated
    """
    where: VerificationTokenBoolExp!
  ): VerificationTokenMutationResponse

  """
  update single row of the table: "verification_token"
  """
  updateVerificationTokenByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: VerificationTokenSetInput
    pk_columns: VerificationTokenPkColumnsInput!
  ): VerificationToken

  """
  update multiples rows of table: "verification_token"
  """
  updateVerificationTokenMany(
    """
    updates to execute, in order
    """
    updates: [VerificationTokenUpdates!]!
  ): [VerificationTokenMutationResponse]
}

type query_root {
  """
  fetch data from the table: "account"
  """
  account(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): [Account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  accountAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): AccountAggregate!

  """
  fetch data from the table: "account" using primary key columns
  """
  accountByPk(id: uuid!): Account

  """
  fetch data from the table: "allowed_role"
  """
  allowedRole(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): [AllowedRole!]!

  """
  fetch aggregated fields from the table: "allowed_role"
  """
  allowedRoleAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): AllowedRoleAggregate!

  """
  fetch data from the table: "allowed_role" using primary key columns
  """
  allowedRoleByPk(role: RolesEnum!, userId: uuid!): AllowedRole

  """
  fetch data from the table: "roles"
  """
  roles(
    """
    distinct select on columns
    """
    distinctOn: [RolesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [RolesOrderBy!]

    """
    filter the rows returned
    """
    where: RolesBoolExp
  ): [Roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [RolesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [RolesOrderBy!]

    """
    filter the rows returned
    """
    where: RolesBoolExp
  ): RolesAggregate!

  """
  fetch data from the table: "roles" using primary key columns
  """
  rolesByPk(value: String!): Roles

  """
  fetch data from the table: "session"
  """
  session(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): [Session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  sessionAggregate(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): SessionAggregate!

  """
  fetch data from the table: "session" using primary key columns
  """
  sessionByPk(id: uuid!): Session

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): UserAggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  userByPk(id: uuid!): User

  """
  fetch data from the table: "verification_token"
  """
  verificationToken(
    """
    distinct select on columns
    """
    distinctOn: [VerificationTokenSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [VerificationTokenOrderBy!]

    """
    filter the rows returned
    """
    where: VerificationTokenBoolExp
  ): [VerificationToken!]!

  """
  fetch aggregated fields from the table: "verification_token"
  """
  verificationTokenAggregate(
    """
    distinct select on columns
    """
    distinctOn: [VerificationTokenSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [VerificationTokenOrderBy!]

    """
    filter the rows returned
    """
    where: VerificationTokenBoolExp
  ): VerificationTokenAggregate!

  """
  fetch data from the table: "verification_token" using primary key columns
  """
  verificationTokenByPk(token: String!): VerificationToken
}

"""
Streaming cursor of the table "roles"
"""
input roles_streamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: roles_streamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input roles_streamCursorValueInput {
  description: String
  value: String
}

input session_aggregate_bool_exp {
  count: session_aggregate_bool_exp_count
}

input session_aggregate_bool_exp_count {
  arguments: [SessionSelectColumn!]
  distinct: Boolean
  filter: SessionBoolExp
  predicate: IntComparisonExp!
}

"""
order by max() on columns of table "session"
"""
input session_max_order_by {
  expires: OrderBy
  id: OrderBy
  sessionToken: OrderBy
  userId: OrderBy
}

"""
order by min() on columns of table "session"
"""
input session_min_order_by {
  expires: OrderBy
  id: OrderBy
  sessionToken: OrderBy
  userId: OrderBy
}

"""
Streaming cursor of the table "session"
"""
input session_streamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: session_streamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input session_streamCursorValueInput {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

type subscription_root {
  """
  fetch data from the table: "account"
  """
  account(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): [Account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  accountAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): AccountAggregate!

  """
  fetch data from the table: "account" using primary key columns
  """
  accountByPk(id: uuid!): Account

  """
  fetch data from the table in a streaming manner: "account"
  """
  accountStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [account_streamCursorInput]!

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): [Account!]!

  """
  fetch data from the table: "allowed_role"
  """
  allowedRole(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): [AllowedRole!]!

  """
  fetch aggregated fields from the table: "allowed_role"
  """
  allowedRoleAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): AllowedRoleAggregate!

  """
  fetch data from the table: "allowed_role" using primary key columns
  """
  allowedRoleByPk(role: RolesEnum!, userId: uuid!): AllowedRole

  """
  fetch data from the table in a streaming manner: "allowed_role"
  """
  allowedRoleStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [allowed_role_streamCursorInput]!

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): [AllowedRole!]!

  """
  fetch data from the table: "roles"
  """
  roles(
    """
    distinct select on columns
    """
    distinctOn: [RolesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [RolesOrderBy!]

    """
    filter the rows returned
    """
    where: RolesBoolExp
  ): [Roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [RolesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [RolesOrderBy!]

    """
    filter the rows returned
    """
    where: RolesBoolExp
  ): RolesAggregate!

  """
  fetch data from the table: "roles" using primary key columns
  """
  rolesByPk(value: String!): Roles

  """
  fetch data from the table in a streaming manner: "roles"
  """
  rolesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [roles_streamCursorInput]!

    """
    filter the rows returned
    """
    where: RolesBoolExp
  ): [Roles!]!

  """
  fetch data from the table: "session"
  """
  session(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): [Session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  sessionAggregate(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): SessionAggregate!

  """
  fetch data from the table: "session" using primary key columns
  """
  sessionByPk(id: uuid!): Session

  """
  fetch data from the table in a streaming manner: "session"
  """
  sessionStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [session_streamCursorInput]!

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): [Session!]!

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): UserAggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  userByPk(id: uuid!): User

  """
  fetch data from the table in a streaming manner: "user"
  """
  userStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [user_streamCursorInput]!

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): [User!]!

  """
  fetch data from the table: "verification_token"
  """
  verificationToken(
    """
    distinct select on columns
    """
    distinctOn: [VerificationTokenSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [VerificationTokenOrderBy!]

    """
    filter the rows returned
    """
    where: VerificationTokenBoolExp
  ): [VerificationToken!]!

  """
  fetch aggregated fields from the table: "verification_token"
  """
  verificationTokenAggregate(
    """
    distinct select on columns
    """
    distinctOn: [VerificationTokenSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [VerificationTokenOrderBy!]

    """
    filter the rows returned
    """
    where: VerificationTokenBoolExp
  ): VerificationTokenAggregate!

  """
  fetch data from the table: "verification_token" using primary key columns
  """
  verificationTokenByPk(token: String!): VerificationToken

  """
  fetch data from the table in a streaming manner: "verification_token"
  """
  verificationTokenStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [verification_token_streamCursorInput]!

    """
    filter the rows returned
    """
    where: VerificationTokenBoolExp
  ): [VerificationToken!]!
}

scalar timestamptz

input user_aggregate_bool_exp {
  count: user_aggregate_bool_exp_count
}

input user_aggregate_bool_exp_count {
  arguments: [UserSelectColumn!]
  distinct: Boolean
  filter: UserBoolExp
  predicate: IntComparisonExp!
}

"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  email: OrderBy
  emailVerified: OrderBy
  id: OrderBy
  image: OrderBy
  name: OrderBy
}

"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  email: OrderBy
  emailVerified: OrderBy
  id: OrderBy
  image: OrderBy
  name: OrderBy
}

"""
Streaming cursor of the table "user"
"""
input user_streamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: user_streamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input user_streamCursorValueInput {
  defaultRole: RolesEnum
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
}

scalar uuid

"""
Streaming cursor of the table "verification_token"
"""
input verification_token_streamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: verification_token_streamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input verification_token_streamCursorValueInput {
  expires: timestamptz
  identifier: String
  token: String
}
