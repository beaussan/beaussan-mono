schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  refresh the cache entry
  """
  refresh: Boolean! = false

  """
  measured in seconds
  """
  ttl: Int! = 60
) on QUERY

"""
columns and relationships of "account"
"""
type Account {
  accessToken: String
  expiresAt: bigint
  id: uuid!
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String!
  providerAccountId: String!
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String!

  """
  An object relationship
  """
  user: User!
  userId: uuid!
}

"""
aggregated selection of "account"
"""
type AccountAggregate {
  aggregate: AccountAggregateFields
  nodes: [Account!]!
}

input AccountAggregateBoolExp {
  count: accountAggregateBoolExpCount
}

"""
aggregate fields of "account"
"""
type AccountAggregateFields {
  avg: AccountAvgFields
  count(columns: [AccountSelectColumn!], distinct: Boolean): Int!
  max: AccountMaxFields
  min: AccountMinFields
  stddev: AccountStddevFields
  stddevPop: AccountStddevPopFields
  stddevSamp: AccountStddevSampFields
  sum: AccountSumFields
  varPop: AccountVarPopFields
  varSamp: AccountVarSampFields
  variance: AccountVarianceFields
}

"""
order by aggregate values of table "account"
"""
input AccountAggregateOrderBy {
  avg: AccountAvgOrderBy
  count: OrderBy
  max: AccountMaxOrderBy
  min: AccountMinOrderBy
  stddev: AccountStddevOrderBy
  stddevPop: AccountStddevPopOrderBy
  stddevSamp: AccountStddevSampOrderBy
  sum: AccountSumOrderBy
  varPop: AccountVarPopOrderBy
  varSamp: AccountVarSampOrderBy
  variance: AccountVarianceOrderBy
}

"""
input type for inserting array relation for remote table "account"
"""
input AccountArrRelInsertInput {
  data: [AccountInsertInput!]!

  """
  upsert condition
  """
  onConflict: AccountOnConflict
}

"""
aggregate avg on columns
"""
type AccountAvgFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
order by avg() on columns of table "account"
"""
input AccountAvgOrderBy {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
"""
input AccountBoolExp {
  _and: [AccountBoolExp!]
  _not: AccountBoolExp
  _or: [AccountBoolExp!]
  accessToken: StringComparisonExp
  expiresAt: BigintComparisonExp
  id: UuidComparisonExp
  idToken: StringComparisonExp
  oauthToken: StringComparisonExp
  oauthTokenSecret: StringComparisonExp
  provider: StringComparisonExp
  providerAccountId: StringComparisonExp
  refreshToken: StringComparisonExp
  refreshTokenExpiresIn: BigintComparisonExp
  scope: StringComparisonExp
  sessionState: StringComparisonExp
  tokenType: StringComparisonExp
  type: StringComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "account"
"""
enum AccountConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  account_pkey
}

"""
input type for incrementing numeric columns in table "account"
"""
input AccountIncInput {
  expiresAt: bigint
  refreshTokenExpiresIn: bigint
}

"""
input type for inserting data into table "account"
"""
input AccountInsertInput {
  accessToken: String
  expiresAt: bigint
  id: uuid
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String
  providerAccountId: String
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String
  user: UserObjRelInsertInput
  userId: uuid
}

"""
aggregate max on columns
"""
type AccountMaxFields {
  accessToken: String
  expiresAt: bigint
  id: uuid
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String
  providerAccountId: String
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String
  userId: uuid
}

"""
order by max() on columns of table "account"
"""
input AccountMaxOrderBy {
  accessToken: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  idToken: OrderBy
  oauthToken: OrderBy
  oauthTokenSecret: OrderBy
  provider: OrderBy
  providerAccountId: OrderBy
  refreshToken: OrderBy
  refreshTokenExpiresIn: OrderBy
  scope: OrderBy
  sessionState: OrderBy
  tokenType: OrderBy
  type: OrderBy
  userId: OrderBy
}

"""
aggregate min on columns
"""
type AccountMinFields {
  accessToken: String
  expiresAt: bigint
  id: uuid
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String
  providerAccountId: String
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String
  userId: uuid
}

"""
order by min() on columns of table "account"
"""
input AccountMinOrderBy {
  accessToken: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  idToken: OrderBy
  oauthToken: OrderBy
  oauthTokenSecret: OrderBy
  provider: OrderBy
  providerAccountId: OrderBy
  refreshToken: OrderBy
  refreshTokenExpiresIn: OrderBy
  scope: OrderBy
  sessionState: OrderBy
  tokenType: OrderBy
  type: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "account"
"""
type AccountMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Account!]!
}

"""
on_conflict condition type for table "account"
"""
input AccountOnConflict {
  constraint: AccountConstraint!
  updateColumns: [AccountUpdateColumn!]! = []
  where: AccountBoolExp
}

"""
Ordering options when selecting data from "account".
"""
input AccountOrderBy {
  accessToken: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  idToken: OrderBy
  oauthToken: OrderBy
  oauthTokenSecret: OrderBy
  provider: OrderBy
  providerAccountId: OrderBy
  refreshToken: OrderBy
  refreshTokenExpiresIn: OrderBy
  scope: OrderBy
  sessionState: OrderBy
  tokenType: OrderBy
  type: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""
primary key columns input for table: account
"""
input AccountPkColumnsInput {
  id: uuid!
}

"""
select columns of table "account"
"""
enum AccountSelectColumn {
  """
  column name
  """
  accessToken

  """
  column name
  """
  expiresAt

  """
  column name
  """
  id

  """
  column name
  """
  idToken

  """
  column name
  """
  oauthToken

  """
  column name
  """
  oauthTokenSecret

  """
  column name
  """
  provider

  """
  column name
  """
  providerAccountId

  """
  column name
  """
  refreshToken

  """
  column name
  """
  refreshTokenExpiresIn

  """
  column name
  """
  scope

  """
  column name
  """
  sessionState

  """
  column name
  """
  tokenType

  """
  column name
  """
  type

  """
  column name
  """
  userId
}

"""
input type for updating data in table "account"
"""
input AccountSetInput {
  accessToken: String
  expiresAt: bigint
  id: uuid
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String
  providerAccountId: String
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String
  userId: uuid
}

"""
aggregate stddev on columns
"""
type AccountStddevFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
order by stddev() on columns of table "account"
"""
input AccountStddevOrderBy {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
aggregate stddevPop on columns
"""
type AccountStddevPopFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
order by stddevPop() on columns of table "account"
"""
input AccountStddevPopOrderBy {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type AccountStddevSampFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
order by stddevSamp() on columns of table "account"
"""
input AccountStddevSampOrderBy {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
Streaming cursor of the table "account"
"""
input AccountStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: AccountStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input AccountStreamCursorValueInput {
  accessToken: String
  expiresAt: bigint
  id: uuid
  idToken: String
  oauthToken: String
  oauthTokenSecret: String
  provider: String
  providerAccountId: String
  refreshToken: String
  refreshTokenExpiresIn: bigint
  scope: String
  sessionState: String
  tokenType: String
  type: String
  userId: uuid
}

"""
aggregate sum on columns
"""
type AccountSumFields {
  expiresAt: bigint
  refreshTokenExpiresIn: bigint
}

"""
order by sum() on columns of table "account"
"""
input AccountSumOrderBy {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
update columns of table "account"
"""
enum AccountUpdateColumn {
  """
  column name
  """
  accessToken

  """
  column name
  """
  expiresAt

  """
  column name
  """
  id

  """
  column name
  """
  idToken

  """
  column name
  """
  oauthToken

  """
  column name
  """
  oauthTokenSecret

  """
  column name
  """
  provider

  """
  column name
  """
  providerAccountId

  """
  column name
  """
  refreshToken

  """
  column name
  """
  refreshTokenExpiresIn

  """
  column name
  """
  scope

  """
  column name
  """
  sessionState

  """
  column name
  """
  tokenType

  """
  column name
  """
  type

  """
  column name
  """
  userId
}

input AccountUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: AccountIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: AccountSetInput

  """
  filter the rows which have to be updated
  """
  where: AccountBoolExp!
}

"""
aggregate varPop on columns
"""
type AccountVarPopFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
order by varPop() on columns of table "account"
"""
input AccountVarPopOrderBy {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
aggregate varSamp on columns
"""
type AccountVarSampFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
order by varSamp() on columns of table "account"
"""
input AccountVarSampOrderBy {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
aggregate variance on columns
"""
type AccountVarianceFields {
  expiresAt: Float
  refreshTokenExpiresIn: Float
}

"""
order by variance() on columns of table "account"
"""
input AccountVarianceOrderBy {
  expiresAt: OrderBy
  refreshTokenExpiresIn: OrderBy
}

"""
columns and relationships of "allowed_role"
"""
type AllowedRole {
  role: RolesEnum!

  """
  An object relationship
  """
  roleByRole: Roles!

  """
  An object relationship
  """
  user: User!
  userId: uuid!
}

"""
aggregated selection of "allowed_role"
"""
type AllowedRoleAggregate {
  aggregate: AllowedRoleAggregateFields
  nodes: [AllowedRole!]!
}

input AllowedRoleAggregateBoolExp {
  count: allowedRoleAggregateBoolExpCount
}

"""
aggregate fields of "allowed_role"
"""
type AllowedRoleAggregateFields {
  count(columns: [AllowedRoleSelectColumn!], distinct: Boolean): Int!
  max: AllowedRoleMaxFields
  min: AllowedRoleMinFields
}

"""
order by aggregate values of table "allowed_role"
"""
input AllowedRoleAggregateOrderBy {
  count: OrderBy
  max: AllowedRoleMaxOrderBy
  min: AllowedRoleMinOrderBy
}

"""
input type for inserting array relation for remote table "allowed_role"
"""
input AllowedRoleArrRelInsertInput {
  data: [AllowedRoleInsertInput!]!

  """
  upsert condition
  """
  onConflict: AllowedRoleOnConflict
}

"""
Boolean expression to filter rows from the table "allowed_role". All fields are combined with a logical 'AND'.
"""
input AllowedRoleBoolExp {
  _and: [AllowedRoleBoolExp!]
  _not: AllowedRoleBoolExp
  _or: [AllowedRoleBoolExp!]
  role: RolesEnumComparisonExp
  roleByRole: RolesBoolExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "allowed_role"
"""
enum AllowedRoleConstraint {
  """
  unique or primary key constraint on columns "user_id", "role"
  """
  allowed_role_pkey
}

"""
input type for inserting data into table "allowed_role"
"""
input AllowedRoleInsertInput {
  role: RolesEnum
  roleByRole: RolesObjRelInsertInput
  user: UserObjRelInsertInput
  userId: uuid
}

"""
aggregate max on columns
"""
type AllowedRoleMaxFields {
  userId: uuid
}

"""
order by max() on columns of table "allowed_role"
"""
input AllowedRoleMaxOrderBy {
  userId: OrderBy
}

"""
aggregate min on columns
"""
type AllowedRoleMinFields {
  userId: uuid
}

"""
order by min() on columns of table "allowed_role"
"""
input AllowedRoleMinOrderBy {
  userId: OrderBy
}

"""
response of any mutation on the table "allowed_role"
"""
type AllowedRoleMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [AllowedRole!]!
}

"""
on_conflict condition type for table "allowed_role"
"""
input AllowedRoleOnConflict {
  constraint: AllowedRoleConstraint!
  updateColumns: [AllowedRoleUpdateColumn!]! = []
  where: AllowedRoleBoolExp
}

"""
Ordering options when selecting data from "allowed_role".
"""
input AllowedRoleOrderBy {
  role: OrderBy
  roleByRole: RolesOrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""
primary key columns input for table: allowed_role
"""
input AllowedRolePkColumnsInput {
  role: RolesEnum!
  userId: uuid!
}

"""
select columns of table "allowed_role"
"""
enum AllowedRoleSelectColumn {
  """
  column name
  """
  role

  """
  column name
  """
  userId
}

"""
input type for updating data in table "allowed_role"
"""
input AllowedRoleSetInput {
  role: RolesEnum
  userId: uuid
}

"""
Streaming cursor of the table "allowed_role"
"""
input AllowedRoleStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: AllowedRoleStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input AllowedRoleStreamCursorValueInput {
  role: RolesEnum
  userId: uuid
}

"""
update columns of table "allowed_role"
"""
enum AllowedRoleUpdateColumn {
  """
  column name
  """
  role

  """
  column name
  """
  userId
}

input AllowedRoleUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: AllowedRoleSetInput

  """
  filter the rows which have to be updated
  """
  where: AllowedRoleBoolExp!
}

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input BigintComparisonExp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _isNull: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "bookmarks"
"""
type Bookmarks {
  displayName: String!
  faviconUrl: String
  id: uuid!
  link: String!
  position: Int

  """
  An object relationship
  """
  user: User!
  userId: uuid!
}

"""
aggregated selection of "bookmarks"
"""
type BookmarksAggregate {
  aggregate: BookmarksAggregateFields
  nodes: [Bookmarks!]!
}

input BookmarksAggregateBoolExp {
  count: bookmarksAggregateBoolExpCount
}

"""
aggregate fields of "bookmarks"
"""
type BookmarksAggregateFields {
  avg: BookmarksAvgFields
  count(columns: [BookmarksSelectColumn!], distinct: Boolean): Int!
  max: BookmarksMaxFields
  min: BookmarksMinFields
  stddev: BookmarksStddevFields
  stddevPop: BookmarksStddevPopFields
  stddevSamp: BookmarksStddevSampFields
  sum: BookmarksSumFields
  varPop: BookmarksVarPopFields
  varSamp: BookmarksVarSampFields
  variance: BookmarksVarianceFields
}

"""
order by aggregate values of table "bookmarks"
"""
input BookmarksAggregateOrderBy {
  avg: BookmarksAvgOrderBy
  count: OrderBy
  max: BookmarksMaxOrderBy
  min: BookmarksMinOrderBy
  stddev: BookmarksStddevOrderBy
  stddevPop: BookmarksStddevPopOrderBy
  stddevSamp: BookmarksStddevSampOrderBy
  sum: BookmarksSumOrderBy
  varPop: BookmarksVarPopOrderBy
  varSamp: BookmarksVarSampOrderBy
  variance: BookmarksVarianceOrderBy
}

"""
input type for inserting array relation for remote table "bookmarks"
"""
input BookmarksArrRelInsertInput {
  data: [BookmarksInsertInput!]!

  """
  upsert condition
  """
  onConflict: BookmarksOnConflict
}

"""
aggregate avg on columns
"""
type BookmarksAvgFields {
  position: Float
}

"""
order by avg() on columns of table "bookmarks"
"""
input BookmarksAvgOrderBy {
  position: OrderBy
}

"""
Boolean expression to filter rows from the table "bookmarks". All fields are combined with a logical 'AND'.
"""
input BookmarksBoolExp {
  _and: [BookmarksBoolExp!]
  _not: BookmarksBoolExp
  _or: [BookmarksBoolExp!]
  displayName: StringComparisonExp
  faviconUrl: StringComparisonExp
  id: UuidComparisonExp
  link: StringComparisonExp
  position: IntComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "bookmarks"
"""
enum BookmarksConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  bookmarks_pkey

  """
  unique or primary key constraint on columns "userId", "position"
  """
  bookmarks_userId_position_key
}

"""
input type for incrementing numeric columns in table "bookmarks"
"""
input BookmarksIncInput {
  position: Int
}

"""
input type for inserting data into table "bookmarks"
"""
input BookmarksInsertInput {
  displayName: String
  faviconUrl: String
  id: uuid
  link: String
  position: Int
  user: UserObjRelInsertInput
  userId: uuid
}

"""
aggregate max on columns
"""
type BookmarksMaxFields {
  displayName: String
  faviconUrl: String
  id: uuid
  link: String
  position: Int
  userId: uuid
}

"""
order by max() on columns of table "bookmarks"
"""
input BookmarksMaxOrderBy {
  displayName: OrderBy
  faviconUrl: OrderBy
  id: OrderBy
  link: OrderBy
  position: OrderBy
  userId: OrderBy
}

"""
aggregate min on columns
"""
type BookmarksMinFields {
  displayName: String
  faviconUrl: String
  id: uuid
  link: String
  position: Int
  userId: uuid
}

"""
order by min() on columns of table "bookmarks"
"""
input BookmarksMinOrderBy {
  displayName: OrderBy
  faviconUrl: OrderBy
  id: OrderBy
  link: OrderBy
  position: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "bookmarks"
"""
type BookmarksMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Bookmarks!]!
}

"""
on_conflict condition type for table "bookmarks"
"""
input BookmarksOnConflict {
  constraint: BookmarksConstraint!
  updateColumns: [BookmarksUpdateColumn!]! = []
  where: BookmarksBoolExp
}

"""
Ordering options when selecting data from "bookmarks".
"""
input BookmarksOrderBy {
  displayName: OrderBy
  faviconUrl: OrderBy
  id: OrderBy
  link: OrderBy
  position: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""
primary key columns input for table: bookmarks
"""
input BookmarksPkColumnsInput {
  id: uuid!
}

"""
select columns of table "bookmarks"
"""
enum BookmarksSelectColumn {
  """
  column name
  """
  displayName

  """
  column name
  """
  faviconUrl

  """
  column name
  """
  id

  """
  column name
  """
  link

  """
  column name
  """
  position

  """
  column name
  """
  userId
}

"""
input type for updating data in table "bookmarks"
"""
input BookmarksSetInput {
  displayName: String
  faviconUrl: String
  id: uuid
  link: String
  position: Int
  userId: uuid
}

"""
aggregate stddev on columns
"""
type BookmarksStddevFields {
  position: Float
}

"""
order by stddev() on columns of table "bookmarks"
"""
input BookmarksStddevOrderBy {
  position: OrderBy
}

"""
aggregate stddevPop on columns
"""
type BookmarksStddevPopFields {
  position: Float
}

"""
order by stddevPop() on columns of table "bookmarks"
"""
input BookmarksStddevPopOrderBy {
  position: OrderBy
}

"""
aggregate stddevSamp on columns
"""
type BookmarksStddevSampFields {
  position: Float
}

"""
order by stddevSamp() on columns of table "bookmarks"
"""
input BookmarksStddevSampOrderBy {
  position: OrderBy
}

"""
Streaming cursor of the table "bookmarks"
"""
input BookmarksStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: BookmarksStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input BookmarksStreamCursorValueInput {
  displayName: String
  faviconUrl: String
  id: uuid
  link: String
  position: Int
  userId: uuid
}

"""
aggregate sum on columns
"""
type BookmarksSumFields {
  position: Int
}

"""
order by sum() on columns of table "bookmarks"
"""
input BookmarksSumOrderBy {
  position: OrderBy
}

"""
update columns of table "bookmarks"
"""
enum BookmarksUpdateColumn {
  """
  column name
  """
  displayName

  """
  column name
  """
  faviconUrl

  """
  column name
  """
  id

  """
  column name
  """
  link

  """
  column name
  """
  position

  """
  column name
  """
  userId
}

input BookmarksUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: BookmarksIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: BookmarksSetInput

  """
  filter the rows which have to be updated
  """
  where: BookmarksBoolExp!
}

"""
aggregate varPop on columns
"""
type BookmarksVarPopFields {
  position: Float
}

"""
order by varPop() on columns of table "bookmarks"
"""
input BookmarksVarPopOrderBy {
  position: OrderBy
}

"""
aggregate varSamp on columns
"""
type BookmarksVarSampFields {
  position: Float
}

"""
order by varSamp() on columns of table "bookmarks"
"""
input BookmarksVarSampOrderBy {
  position: OrderBy
}

"""
aggregate variance on columns
"""
type BookmarksVarianceFields {
  position: Float
}

"""
order by variance() on columns of table "bookmarks"
"""
input BookmarksVarianceOrderBy {
  position: OrderBy
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
ordering argument of a cursor
"""
enum CursorOrdering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
column ordering options
"""
enum OrderBy {
  """
  in ascending order, nulls last
  """
  ASC

  """
  in ascending order, nulls first
  """
  ASC_NULLS_FIRST

  """
  in ascending order, nulls last
  """
  ASC_NULLS_LAST

  """
  in descending order, nulls first
  """
  DESC

  """
  in descending order, nulls first
  """
  DESC_NULLS_FIRST

  """
  in descending order, nulls last
  """
  DESC_NULLS_LAST
}

"""
columns and relationships of "roles"
"""
type Roles {
  """
  An array relationship
  """
  allowedRoles(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): [AllowedRole!]!

  """
  An aggregate relationship
  """
  allowedRolesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): AllowedRoleAggregate!
  description: String

  """
  An array relationship
  """
  users(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): [User!]!

  """
  An aggregate relationship
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): UserAggregate!
  value: String!
}

"""
aggregated selection of "roles"
"""
type RolesAggregate {
  aggregate: RolesAggregateFields
  nodes: [Roles!]!
}

"""
aggregate fields of "roles"
"""
type RolesAggregateFields {
  count(columns: [RolesSelectColumn!], distinct: Boolean): Int!
  max: RolesMaxFields
  min: RolesMinFields
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input RolesBoolExp {
  _and: [RolesBoolExp!]
  _not: RolesBoolExp
  _or: [RolesBoolExp!]
  allowedRoles: AllowedRoleBoolExp
  allowedRolesAggregate: AllowedRoleAggregateBoolExp
  description: StringComparisonExp
  users: UserBoolExp
  usersAggregate: UserAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "roles"
"""
enum RolesConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  roles_pkey
}

enum RolesEnum {
  USER
}

"""
Boolean expression to compare columns of type "RolesEnum". All fields are combined with logical 'AND'.
"""
input RolesEnumComparisonExp {
  _eq: RolesEnum
  _in: [RolesEnum!]
  _isNull: Boolean
  _neq: RolesEnum
  _nin: [RolesEnum!]
}

"""
input type for inserting data into table "roles"
"""
input RolesInsertInput {
  allowedRoles: AllowedRoleArrRelInsertInput
  description: String
  users: UserArrRelInsertInput
  value: String
}

"""
aggregate max on columns
"""
type RolesMaxFields {
  description: String
  value: String
}

"""
aggregate min on columns
"""
type RolesMinFields {
  description: String
  value: String
}

"""
response of any mutation on the table "roles"
"""
type RolesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input RolesObjRelInsertInput {
  data: RolesInsertInput!

  """
  upsert condition
  """
  onConflict: RolesOnConflict
}

"""
on_conflict condition type for table "roles"
"""
input RolesOnConflict {
  constraint: RolesConstraint!
  updateColumns: [RolesUpdateColumn!]! = []
  where: RolesBoolExp
}

"""
Ordering options when selecting data from "roles".
"""
input RolesOrderBy {
  allowedRolesAggregate: AllowedRoleAggregateOrderBy
  description: OrderBy
  usersAggregate: UserAggregateOrderBy
  value: OrderBy
}

"""
primary key columns input for table: roles
"""
input RolesPkColumnsInput {
  value: String!
}

"""
select columns of table "roles"
"""
enum RolesSelectColumn {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

"""
input type for updating data in table "roles"
"""
input RolesSetInput {
  description: String
  value: String
}

"""
Streaming cursor of the table "roles"
"""
input RolesStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: RolesStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input RolesStreamCursorValueInput {
  description: String
  value: String
}

"""
update columns of table "roles"
"""
enum RolesUpdateColumn {
  """
  column name
  """
  description

  """
  column name
  """
  value
}

input RolesUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: RolesSetInput

  """
  filter the rows which have to be updated
  """
  where: RolesBoolExp!
}

"""
columns and relationships of "session"
"""
type Session {
  expires: timestamptz!
  id: uuid!
  sessionToken: String!

  """
  An object relationship
  """
  user: User!
  userId: uuid!
}

"""
aggregated selection of "session"
"""
type SessionAggregate {
  aggregate: SessionAggregateFields
  nodes: [Session!]!
}

input SessionAggregateBoolExp {
  count: sessionAggregateBoolExpCount
}

"""
aggregate fields of "session"
"""
type SessionAggregateFields {
  count(columns: [SessionSelectColumn!], distinct: Boolean): Int!
  max: SessionMaxFields
  min: SessionMinFields
}

"""
order by aggregate values of table "session"
"""
input SessionAggregateOrderBy {
  count: OrderBy
  max: SessionMaxOrderBy
  min: SessionMinOrderBy
}

"""
input type for inserting array relation for remote table "session"
"""
input SessionArrRelInsertInput {
  data: [SessionInsertInput!]!

  """
  upsert condition
  """
  onConflict: SessionOnConflict
}

"""
Boolean expression to filter rows from the table "session". All fields are combined with a logical 'AND'.
"""
input SessionBoolExp {
  _and: [SessionBoolExp!]
  _not: SessionBoolExp
  _or: [SessionBoolExp!]
  expires: TimestamptzComparisonExp
  id: UuidComparisonExp
  sessionToken: StringComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "session"
"""
enum SessionConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  session_pkey
}

"""
input type for inserting data into table "session"
"""
input SessionInsertInput {
  expires: timestamptz
  id: uuid
  sessionToken: String
  user: UserObjRelInsertInput
  userId: uuid
}

"""
aggregate max on columns
"""
type SessionMaxFields {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
order by max() on columns of table "session"
"""
input SessionMaxOrderBy {
  expires: OrderBy
  id: OrderBy
  sessionToken: OrderBy
  userId: OrderBy
}

"""
aggregate min on columns
"""
type SessionMinFields {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
order by min() on columns of table "session"
"""
input SessionMinOrderBy {
  expires: OrderBy
  id: OrderBy
  sessionToken: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "session"
"""
type SessionMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Session!]!
}

"""
on_conflict condition type for table "session"
"""
input SessionOnConflict {
  constraint: SessionConstraint!
  updateColumns: [SessionUpdateColumn!]! = []
  where: SessionBoolExp
}

"""
Ordering options when selecting data from "session".
"""
input SessionOrderBy {
  expires: OrderBy
  id: OrderBy
  sessionToken: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""
primary key columns input for table: session
"""
input SessionPkColumnsInput {
  id: uuid!
}

"""
select columns of table "session"
"""
enum SessionSelectColumn {
  """
  column name
  """
  expires

  """
  column name
  """
  id

  """
  column name
  """
  sessionToken

  """
  column name
  """
  userId
}

"""
input type for updating data in table "session"
"""
input SessionSetInput {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
Streaming cursor of the table "session"
"""
input SessionStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: SessionStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input SessionStreamCursorValueInput {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
update columns of table "session"
"""
enum SessionUpdateColumn {
  """
  column name
  """
  expires

  """
  column name
  """
  id

  """
  column name
  """
  sessionToken

  """
  column name
  """
  userId
}

input SessionUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: SessionSetInput

  """
  filter the rows which have to be updated
  """
  where: SessionBoolExp!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "traefikRoutes"
"""
type TraefikRoutes {
  calculatedUrl: String!
  createdAt: timestamptz
  faviconUrl: String
  friendlyName: String
  isSown: Boolean!
  isUp: Boolean!
  lastSeenAlive: timestamptz!
  name: String!
  provider: String!
  rule: String!
  service: String!
}

"""
aggregated selection of "traefikRoutes"
"""
type TraefikRoutesAggregate {
  aggregate: TraefikRoutesAggregateFields
  nodes: [TraefikRoutes!]!
}

"""
aggregate fields of "traefikRoutes"
"""
type TraefikRoutesAggregateFields {
  count(columns: [TraefikRoutesSelectColumn!], distinct: Boolean): Int!
  max: TraefikRoutesMaxFields
  min: TraefikRoutesMinFields
}

"""
Boolean expression to filter rows from the table "traefikRoutes". All fields are combined with a logical 'AND'.
"""
input TraefikRoutesBoolExp {
  _and: [TraefikRoutesBoolExp!]
  _not: TraefikRoutesBoolExp
  _or: [TraefikRoutesBoolExp!]
  calculatedUrl: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  faviconUrl: StringComparisonExp
  friendlyName: StringComparisonExp
  isSown: BooleanComparisonExp
  isUp: BooleanComparisonExp
  lastSeenAlive: TimestamptzComparisonExp
  name: StringComparisonExp
  provider: StringComparisonExp
  rule: StringComparisonExp
  service: StringComparisonExp
}

"""
unique or primary key constraints on table "traefikRoutes"
"""
enum TraefikRoutesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  traefikRoutes_pkey
}

"""
input type for inserting data into table "traefikRoutes"
"""
input TraefikRoutesInsertInput {
  calculatedUrl: String
  createdAt: timestamptz
  faviconUrl: String
  friendlyName: String
  isSown: Boolean
  isUp: Boolean
  lastSeenAlive: timestamptz
  name: String
  provider: String
  rule: String
  service: String
}

"""
aggregate max on columns
"""
type TraefikRoutesMaxFields {
  calculatedUrl: String
  createdAt: timestamptz
  faviconUrl: String
  friendlyName: String
  lastSeenAlive: timestamptz
  name: String
  provider: String
  rule: String
  service: String
}

"""
aggregate min on columns
"""
type TraefikRoutesMinFields {
  calculatedUrl: String
  createdAt: timestamptz
  faviconUrl: String
  friendlyName: String
  lastSeenAlive: timestamptz
  name: String
  provider: String
  rule: String
  service: String
}

"""
response of any mutation on the table "traefikRoutes"
"""
type TraefikRoutesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [TraefikRoutes!]!
}

"""
on_conflict condition type for table "traefikRoutes"
"""
input TraefikRoutesOnConflict {
  constraint: TraefikRoutesConstraint!
  updateColumns: [TraefikRoutesUpdateColumn!]! = []
  where: TraefikRoutesBoolExp
}

"""
Ordering options when selecting data from "traefikRoutes".
"""
input TraefikRoutesOrderBy {
  calculatedUrl: OrderBy
  createdAt: OrderBy
  faviconUrl: OrderBy
  friendlyName: OrderBy
  isSown: OrderBy
  isUp: OrderBy
  lastSeenAlive: OrderBy
  name: OrderBy
  provider: OrderBy
  rule: OrderBy
  service: OrderBy
}

"""
primary key columns input for table: traefikRoutes
"""
input TraefikRoutesPkColumnsInput {
  name: String!
}

"""
select columns of table "traefikRoutes"
"""
enum TraefikRoutesSelectColumn {
  """
  column name
  """
  calculatedUrl

  """
  column name
  """
  createdAt

  """
  column name
  """
  faviconUrl

  """
  column name
  """
  friendlyName

  """
  column name
  """
  isSown

  """
  column name
  """
  isUp

  """
  column name
  """
  lastSeenAlive

  """
  column name
  """
  name

  """
  column name
  """
  provider

  """
  column name
  """
  rule

  """
  column name
  """
  service
}

"""
input type for updating data in table "traefikRoutes"
"""
input TraefikRoutesSetInput {
  calculatedUrl: String
  createdAt: timestamptz
  faviconUrl: String
  friendlyName: String
  isSown: Boolean
  isUp: Boolean
  lastSeenAlive: timestamptz
  name: String
  provider: String
  rule: String
  service: String
}

"""
Streaming cursor of the table "traefikRoutes"
"""
input TraefikRoutesStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: TraefikRoutesStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input TraefikRoutesStreamCursorValueInput {
  calculatedUrl: String
  createdAt: timestamptz
  faviconUrl: String
  friendlyName: String
  isSown: Boolean
  isUp: Boolean
  lastSeenAlive: timestamptz
  name: String
  provider: String
  rule: String
  service: String
}

"""
update columns of table "traefikRoutes"
"""
enum TraefikRoutesUpdateColumn {
  """
  column name
  """
  calculatedUrl

  """
  column name
  """
  createdAt

  """
  column name
  """
  faviconUrl

  """
  column name
  """
  friendlyName

  """
  column name
  """
  isSown

  """
  column name
  """
  isUp

  """
  column name
  """
  lastSeenAlive

  """
  column name
  """
  name

  """
  column name
  """
  provider

  """
  column name
  """
  rule

  """
  column name
  """
  service
}

input TraefikRoutesUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: TraefikRoutesSetInput

  """
  filter the rows which have to be updated
  """
  where: TraefikRoutesBoolExp!
}

"""
columns and relationships of "user"
"""
type User {
  """
  An array relationship
  """
  accounts(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): [Account!]!

  """
  An aggregate relationship
  """
  accountsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): AccountAggregate!

  """
  An array relationship
  """
  allowedRoles(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): [AllowedRole!]!

  """
  An aggregate relationship
  """
  allowedRolesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): AllowedRoleAggregate!

  """
  An array relationship
  """
  bookmarks(
    """
    distinct select on columns
    """
    distinctOn: [BookmarksSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BookmarksOrderBy!]

    """
    filter the rows returned
    """
    where: BookmarksBoolExp
  ): [Bookmarks!]!

  """
  An aggregate relationship
  """
  bookmarksAggregate(
    """
    distinct select on columns
    """
    distinctOn: [BookmarksSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BookmarksOrderBy!]

    """
    filter the rows returned
    """
    where: BookmarksBoolExp
  ): BookmarksAggregate!
  canSeeTraefikContent: Boolean!
  createdAt: timestamptz!
  defaultRole: RolesEnum
  email: String!
  emailVerified: timestamptz
  id: uuid!
  image: String
  name: String

  """
  An object relationship
  """
  role: Roles

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): [Session!]!

  """
  An aggregate relationship
  """
  sessionsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): SessionAggregate!
  todoistApiToken: String
  updatedAt: timestamptz!
}

"""
aggregated selection of "user"
"""
type UserAggregate {
  aggregate: UserAggregateFields
  nodes: [User!]!
}

input UserAggregateBoolExp {
  bool_and: userAggregateBoolExpBool_and
  bool_or: userAggregateBoolExpBool_or
  count: userAggregateBoolExpCount
}

"""
aggregate fields of "user"
"""
type UserAggregateFields {
  count(columns: [UserSelectColumn!], distinct: Boolean): Int!
  max: UserMaxFields
  min: UserMinFields
}

"""
order by aggregate values of table "user"
"""
input UserAggregateOrderBy {
  count: OrderBy
  max: UserMaxOrderBy
  min: UserMinOrderBy
}

"""
input type for inserting array relation for remote table "user"
"""
input UserArrRelInsertInput {
  data: [UserInsertInput!]!

  """
  upsert condition
  """
  onConflict: UserOnConflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input UserBoolExp {
  _and: [UserBoolExp!]
  _not: UserBoolExp
  _or: [UserBoolExp!]
  accounts: AccountBoolExp
  accountsAggregate: AccountAggregateBoolExp
  allowedRoles: AllowedRoleBoolExp
  allowedRolesAggregate: AllowedRoleAggregateBoolExp
  bookmarks: BookmarksBoolExp
  bookmarksAggregate: BookmarksAggregateBoolExp
  canSeeTraefikContent: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  defaultRole: RolesEnumComparisonExp
  email: StringComparisonExp
  emailVerified: TimestamptzComparisonExp
  id: UuidComparisonExp
  image: StringComparisonExp
  name: StringComparisonExp
  role: RolesBoolExp
  sessions: SessionBoolExp
  sessionsAggregate: SessionAggregateBoolExp
  todoistApiToken: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "user"
"""
enum UserConstraint {
  """
  unique or primary key constraint on columns "email"
  """
  user_email_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "user"
"""
input UserInsertInput {
  accounts: AccountArrRelInsertInput
  allowedRoles: AllowedRoleArrRelInsertInput
  bookmarks: BookmarksArrRelInsertInput
  canSeeTraefikContent: Boolean
  createdAt: timestamptz
  defaultRole: RolesEnum
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  role: RolesObjRelInsertInput
  sessions: SessionArrRelInsertInput
  todoistApiToken: String
  updatedAt: timestamptz
}

"""
aggregate max on columns
"""
type UserMaxFields {
  createdAt: timestamptz
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  todoistApiToken: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "user"
"""
input UserMaxOrderBy {
  createdAt: OrderBy
  email: OrderBy
  emailVerified: OrderBy
  id: OrderBy
  image: OrderBy
  name: OrderBy
  todoistApiToken: OrderBy
  updatedAt: OrderBy
}

"""
aggregate min on columns
"""
type UserMinFields {
  createdAt: timestamptz
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  todoistApiToken: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "user"
"""
input UserMinOrderBy {
  createdAt: OrderBy
  email: OrderBy
  emailVerified: OrderBy
  id: OrderBy
  image: OrderBy
  name: OrderBy
  todoistApiToken: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "user"
"""
type UserMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [User!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input UserObjRelInsertInput {
  data: UserInsertInput!

  """
  upsert condition
  """
  onConflict: UserOnConflict
}

"""
on_conflict condition type for table "user"
"""
input UserOnConflict {
  constraint: UserConstraint!
  updateColumns: [UserUpdateColumn!]! = []
  where: UserBoolExp
}

"""
Ordering options when selecting data from "user".
"""
input UserOrderBy {
  accountsAggregate: AccountAggregateOrderBy
  allowedRolesAggregate: AllowedRoleAggregateOrderBy
  bookmarksAggregate: BookmarksAggregateOrderBy
  canSeeTraefikContent: OrderBy
  createdAt: OrderBy
  defaultRole: OrderBy
  email: OrderBy
  emailVerified: OrderBy
  id: OrderBy
  image: OrderBy
  name: OrderBy
  role: RolesOrderBy
  sessionsAggregate: SessionAggregateOrderBy
  todoistApiToken: OrderBy
  updatedAt: OrderBy
}

"""
primary key columns input for table: user
"""
input UserPkColumnsInput {
  id: uuid!
}

"""
select columns of table "user"
"""
enum UserSelectColumn {
  """
  column name
  """
  canSeeTraefikContent

  """
  column name
  """
  createdAt

  """
  column name
  """
  defaultRole

  """
  column name
  """
  email

  """
  column name
  """
  emailVerified

  """
  column name
  """
  id

  """
  column name
  """
  image

  """
  column name
  """
  name

  """
  column name
  """
  todoistApiToken

  """
  column name
  """
  updatedAt
}

"""
select "userAggregateBoolExpBool_andArgumentsColumns" columns of table "user"
"""
enum UserSelectColumnUserAggregateBoolExpBool_andArgumentsColumns {
  """
  column name
  """
  canSeeTraefikContent
}

"""
select "userAggregateBoolExpBool_orArgumentsColumns" columns of table "user"
"""
enum UserSelectColumnUserAggregateBoolExpBool_orArgumentsColumns {
  """
  column name
  """
  canSeeTraefikContent
}

"""
input type for updating data in table "user"
"""
input UserSetInput {
  canSeeTraefikContent: Boolean
  createdAt: timestamptz
  defaultRole: RolesEnum
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  todoistApiToken: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "user"
"""
input UserStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: UserStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input UserStreamCursorValueInput {
  canSeeTraefikContent: Boolean
  createdAt: timestamptz
  defaultRole: RolesEnum
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  todoistApiToken: String
  updatedAt: timestamptz
}

"""
update columns of table "user"
"""
enum UserUpdateColumn {
  """
  column name
  """
  canSeeTraefikContent

  """
  column name
  """
  createdAt

  """
  column name
  """
  defaultRole

  """
  column name
  """
  email

  """
  column name
  """
  emailVerified

  """
  column name
  """
  id

  """
  column name
  """
  image

  """
  column name
  """
  name

  """
  column name
  """
  todoistApiToken

  """
  column name
  """
  updatedAt
}

input UserUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: UserSetInput

  """
  filter the rows which have to be updated
  """
  where: UserBoolExp!
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "verification_token"
"""
type VerificationToken {
  expires: timestamptz!
  identifier: String!
  token: String!
}

"""
aggregated selection of "verification_token"
"""
type VerificationTokenAggregate {
  aggregate: VerificationTokenAggregateFields
  nodes: [VerificationToken!]!
}

"""
aggregate fields of "verification_token"
"""
type VerificationTokenAggregateFields {
  count(columns: [VerificationTokenSelectColumn!], distinct: Boolean): Int!
  max: VerificationTokenMaxFields
  min: VerificationTokenMinFields
}

"""
Boolean expression to filter rows from the table "verification_token". All fields are combined with a logical 'AND'.
"""
input VerificationTokenBoolExp {
  _and: [VerificationTokenBoolExp!]
  _not: VerificationTokenBoolExp
  _or: [VerificationTokenBoolExp!]
  expires: TimestamptzComparisonExp
  identifier: StringComparisonExp
  token: StringComparisonExp
}

"""
unique or primary key constraints on table "verification_token"
"""
enum VerificationTokenConstraint {
  """
  unique or primary key constraint on columns "token"
  """
  verification_token_pkey
}

"""
input type for inserting data into table "verification_token"
"""
input VerificationTokenInsertInput {
  expires: timestamptz
  identifier: String
  token: String
}

"""
aggregate max on columns
"""
type VerificationTokenMaxFields {
  expires: timestamptz
  identifier: String
  token: String
}

"""
aggregate min on columns
"""
type VerificationTokenMinFields {
  expires: timestamptz
  identifier: String
  token: String
}

"""
response of any mutation on the table "verification_token"
"""
type VerificationTokenMutationResponse {
  """
  number of rows affected by the mutation
  """
  affectedRows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [VerificationToken!]!
}

"""
on_conflict condition type for table "verification_token"
"""
input VerificationTokenOnConflict {
  constraint: VerificationTokenConstraint!
  updateColumns: [VerificationTokenUpdateColumn!]! = []
  where: VerificationTokenBoolExp
}

"""
Ordering options when selecting data from "verification_token".
"""
input VerificationTokenOrderBy {
  expires: OrderBy
  identifier: OrderBy
  token: OrderBy
}

"""
primary key columns input for table: verification_token
"""
input VerificationTokenPkColumnsInput {
  token: String!
}

"""
select columns of table "verification_token"
"""
enum VerificationTokenSelectColumn {
  """
  column name
  """
  expires

  """
  column name
  """
  identifier

  """
  column name
  """
  token
}

"""
input type for updating data in table "verification_token"
"""
input VerificationTokenSetInput {
  expires: timestamptz
  identifier: String
  token: String
}

"""
Streaming cursor of the table "verification_token"
"""
input VerificationTokenStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: VerificationTokenStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input VerificationTokenStreamCursorValueInput {
  expires: timestamptz
  identifier: String
  token: String
}

"""
update columns of table "verification_token"
"""
enum VerificationTokenUpdateColumn {
  """
  column name
  """
  expires

  """
  column name
  """
  identifier

  """
  column name
  """
  token
}

input VerificationTokenUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: VerificationTokenSetInput

  """
  filter the rows which have to be updated
  """
  where: VerificationTokenBoolExp!
}

input accountAggregateBoolExpCount {
  arguments: [AccountSelectColumn!]
  distinct: Boolean
  filter: AccountBoolExp
  predicate: IntComparisonExp!
}

input allowedRoleAggregateBoolExpCount {
  arguments: [AllowedRoleSelectColumn!]
  distinct: Boolean
  filter: AllowedRoleBoolExp
  predicate: IntComparisonExp!
}

scalar bigint

input bookmarksAggregateBoolExpCount {
  arguments: [BookmarksSelectColumn!]
  distinct: Boolean
  filter: BookmarksBoolExp
  predicate: IntComparisonExp!
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "account"
  """
  deleteAccount(
    """
    filter the rows which have to be deleted
    """
    where: AccountBoolExp!
  ): AccountMutationResponse

  """
  delete single row from the table: "account"
  """
  deleteAccountByPk(id: uuid!): Account

  """
  delete data from the table: "allowed_role"
  """
  deleteAllowedRole(
    """
    filter the rows which have to be deleted
    """
    where: AllowedRoleBoolExp!
  ): AllowedRoleMutationResponse

  """
  delete single row from the table: "allowed_role"
  """
  deleteAllowedRoleByPk(role: RolesEnum!, userId: uuid!): AllowedRole

  """
  delete data from the table: "bookmarks"
  """
  deleteBookmarks(
    """
    filter the rows which have to be deleted
    """
    where: BookmarksBoolExp!
  ): BookmarksMutationResponse

  """
  delete single row from the table: "bookmarks"
  """
  deleteBookmarksByPk(id: uuid!): Bookmarks

  """
  delete data from the table: "roles"
  """
  deleteRoles(
    """
    filter the rows which have to be deleted
    """
    where: RolesBoolExp!
  ): RolesMutationResponse

  """
  delete single row from the table: "roles"
  """
  deleteRolesByPk(value: String!): Roles

  """
  delete data from the table: "session"
  """
  deleteSession(
    """
    filter the rows which have to be deleted
    """
    where: SessionBoolExp!
  ): SessionMutationResponse

  """
  delete single row from the table: "session"
  """
  deleteSessionByPk(id: uuid!): Session

  """
  delete data from the table: "traefikRoutes"
  """
  deleteTraefikRoutes(
    """
    filter the rows which have to be deleted
    """
    where: TraefikRoutesBoolExp!
  ): TraefikRoutesMutationResponse

  """
  delete single row from the table: "traefikRoutes"
  """
  deleteTraefikRoutesByPk(name: String!): TraefikRoutes

  """
  delete data from the table: "user"
  """
  deleteUser(
    """
    filter the rows which have to be deleted
    """
    where: UserBoolExp!
  ): UserMutationResponse

  """
  delete single row from the table: "user"
  """
  deleteUserByPk(id: uuid!): User

  """
  delete data from the table: "verification_token"
  """
  deleteVerificationToken(
    """
    filter the rows which have to be deleted
    """
    where: VerificationTokenBoolExp!
  ): VerificationTokenMutationResponse

  """
  delete single row from the table: "verification_token"
  """
  deleteVerificationTokenByPk(token: String!): VerificationToken

  """
  insert data into the table: "account"
  """
  insertAccount(
    """
    the rows to be inserted
    """
    objects: [AccountInsertInput!]!

    """
    upsert condition
    """
    onConflict: AccountOnConflict
  ): AccountMutationResponse

  """
  insert a single row into the table: "account"
  """
  insertAccountOne(
    """
    the row to be inserted
    """
    object: AccountInsertInput!

    """
    upsert condition
    """
    onConflict: AccountOnConflict
  ): Account

  """
  insert data into the table: "allowed_role"
  """
  insertAllowedRole(
    """
    the rows to be inserted
    """
    objects: [AllowedRoleInsertInput!]!

    """
    upsert condition
    """
    onConflict: AllowedRoleOnConflict
  ): AllowedRoleMutationResponse

  """
  insert a single row into the table: "allowed_role"
  """
  insertAllowedRoleOne(
    """
    the row to be inserted
    """
    object: AllowedRoleInsertInput!

    """
    upsert condition
    """
    onConflict: AllowedRoleOnConflict
  ): AllowedRole

  """
  insert data into the table: "bookmarks"
  """
  insertBookmarks(
    """
    the rows to be inserted
    """
    objects: [BookmarksInsertInput!]!

    """
    upsert condition
    """
    onConflict: BookmarksOnConflict
  ): BookmarksMutationResponse

  """
  insert a single row into the table: "bookmarks"
  """
  insertBookmarksOne(
    """
    the row to be inserted
    """
    object: BookmarksInsertInput!

    """
    upsert condition
    """
    onConflict: BookmarksOnConflict
  ): Bookmarks

  """
  insert data into the table: "roles"
  """
  insertRoles(
    """
    the rows to be inserted
    """
    objects: [RolesInsertInput!]!

    """
    upsert condition
    """
    onConflict: RolesOnConflict
  ): RolesMutationResponse

  """
  insert a single row into the table: "roles"
  """
  insertRolesOne(
    """
    the row to be inserted
    """
    object: RolesInsertInput!

    """
    upsert condition
    """
    onConflict: RolesOnConflict
  ): Roles

  """
  insert data into the table: "session"
  """
  insertSession(
    """
    the rows to be inserted
    """
    objects: [SessionInsertInput!]!

    """
    upsert condition
    """
    onConflict: SessionOnConflict
  ): SessionMutationResponse

  """
  insert a single row into the table: "session"
  """
  insertSessionOne(
    """
    the row to be inserted
    """
    object: SessionInsertInput!

    """
    upsert condition
    """
    onConflict: SessionOnConflict
  ): Session

  """
  insert data into the table: "traefikRoutes"
  """
  insertTraefikRoutes(
    """
    the rows to be inserted
    """
    objects: [TraefikRoutesInsertInput!]!

    """
    upsert condition
    """
    onConflict: TraefikRoutesOnConflict
  ): TraefikRoutesMutationResponse

  """
  insert a single row into the table: "traefikRoutes"
  """
  insertTraefikRoutesOne(
    """
    the row to be inserted
    """
    object: TraefikRoutesInsertInput!

    """
    upsert condition
    """
    onConflict: TraefikRoutesOnConflict
  ): TraefikRoutes

  """
  insert data into the table: "user"
  """
  insertUser(
    """
    the rows to be inserted
    """
    objects: [UserInsertInput!]!

    """
    upsert condition
    """
    onConflict: UserOnConflict
  ): UserMutationResponse

  """
  insert a single row into the table: "user"
  """
  insertUserOne(
    """
    the row to be inserted
    """
    object: UserInsertInput!

    """
    upsert condition
    """
    onConflict: UserOnConflict
  ): User

  """
  insert data into the table: "verification_token"
  """
  insertVerificationToken(
    """
    the rows to be inserted
    """
    objects: [VerificationTokenInsertInput!]!

    """
    upsert condition
    """
    onConflict: VerificationTokenOnConflict
  ): VerificationTokenMutationResponse

  """
  insert a single row into the table: "verification_token"
  """
  insertVerificationTokenOne(
    """
    the row to be inserted
    """
    object: VerificationTokenInsertInput!

    """
    upsert condition
    """
    onConflict: VerificationTokenOnConflict
  ): VerificationToken

  """
  update data of the table: "account"
  """
  updateAccount(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: AccountIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: AccountSetInput

    """
    filter the rows which have to be updated
    """
    where: AccountBoolExp!
  ): AccountMutationResponse

  """
  update single row of the table: "account"
  """
  updateAccountByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: AccountIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: AccountSetInput
    pkColumns: AccountPkColumnsInput!
  ): Account

  """
  update multiples rows of table: "account"
  """
  updateAccountMany(
    """
    updates to execute, in order
    """
    updates: [AccountUpdates!]!
  ): [AccountMutationResponse]

  """
  update data of the table: "allowed_role"
  """
  updateAllowedRole(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: AllowedRoleSetInput

    """
    filter the rows which have to be updated
    """
    where: AllowedRoleBoolExp!
  ): AllowedRoleMutationResponse

  """
  update single row of the table: "allowed_role"
  """
  updateAllowedRoleByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: AllowedRoleSetInput
    pkColumns: AllowedRolePkColumnsInput!
  ): AllowedRole

  """
  update multiples rows of table: "allowed_role"
  """
  updateAllowedRoleMany(
    """
    updates to execute, in order
    """
    updates: [AllowedRoleUpdates!]!
  ): [AllowedRoleMutationResponse]

  """
  update data of the table: "bookmarks"
  """
  updateBookmarks(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: BookmarksIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: BookmarksSetInput

    """
    filter the rows which have to be updated
    """
    where: BookmarksBoolExp!
  ): BookmarksMutationResponse

  """
  update single row of the table: "bookmarks"
  """
  updateBookmarksByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: BookmarksIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: BookmarksSetInput
    pkColumns: BookmarksPkColumnsInput!
  ): Bookmarks

  """
  update multiples rows of table: "bookmarks"
  """
  updateBookmarksMany(
    """
    updates to execute, in order
    """
    updates: [BookmarksUpdates!]!
  ): [BookmarksMutationResponse]

  """
  update data of the table: "roles"
  """
  updateRoles(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: RolesSetInput

    """
    filter the rows which have to be updated
    """
    where: RolesBoolExp!
  ): RolesMutationResponse

  """
  update single row of the table: "roles"
  """
  updateRolesByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: RolesSetInput
    pkColumns: RolesPkColumnsInput!
  ): Roles

  """
  update multiples rows of table: "roles"
  """
  updateRolesMany(
    """
    updates to execute, in order
    """
    updates: [RolesUpdates!]!
  ): [RolesMutationResponse]

  """
  update data of the table: "session"
  """
  updateSession(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: SessionSetInput

    """
    filter the rows which have to be updated
    """
    where: SessionBoolExp!
  ): SessionMutationResponse

  """
  update single row of the table: "session"
  """
  updateSessionByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: SessionSetInput
    pkColumns: SessionPkColumnsInput!
  ): Session

  """
  update multiples rows of table: "session"
  """
  updateSessionMany(
    """
    updates to execute, in order
    """
    updates: [SessionUpdates!]!
  ): [SessionMutationResponse]

  """
  update data of the table: "traefikRoutes"
  """
  updateTraefikRoutes(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: TraefikRoutesSetInput

    """
    filter the rows which have to be updated
    """
    where: TraefikRoutesBoolExp!
  ): TraefikRoutesMutationResponse

  """
  update single row of the table: "traefikRoutes"
  """
  updateTraefikRoutesByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: TraefikRoutesSetInput
    pkColumns: TraefikRoutesPkColumnsInput!
  ): TraefikRoutes

  """
  update multiples rows of table: "traefikRoutes"
  """
  updateTraefikRoutesMany(
    """
    updates to execute, in order
    """
    updates: [TraefikRoutesUpdates!]!
  ): [TraefikRoutesMutationResponse]

  """
  update data of the table: "user"
  """
  updateUser(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: UserSetInput

    """
    filter the rows which have to be updated
    """
    where: UserBoolExp!
  ): UserMutationResponse

  """
  update single row of the table: "user"
  """
  updateUserByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: UserSetInput
    pkColumns: UserPkColumnsInput!
  ): User

  """
  update multiples rows of table: "user"
  """
  updateUserMany(
    """
    updates to execute, in order
    """
    updates: [UserUpdates!]!
  ): [UserMutationResponse]

  """
  update data of the table: "verification_token"
  """
  updateVerificationToken(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: VerificationTokenSetInput

    """
    filter the rows which have to be updated
    """
    where: VerificationTokenBoolExp!
  ): VerificationTokenMutationResponse

  """
  update single row of the table: "verification_token"
  """
  updateVerificationTokenByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: VerificationTokenSetInput
    pkColumns: VerificationTokenPkColumnsInput!
  ): VerificationToken

  """
  update multiples rows of table: "verification_token"
  """
  updateVerificationTokenMany(
    """
    updates to execute, in order
    """
    updates: [VerificationTokenUpdates!]!
  ): [VerificationTokenMutationResponse]
}

type query_root {
  """
  fetch data from the table: "account"
  """
  account(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): [Account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  accountAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): AccountAggregate!

  """
  fetch data from the table: "account" using primary key columns
  """
  accountByPk(id: uuid!): Account

  """
  fetch data from the table: "allowed_role"
  """
  allowedRole(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): [AllowedRole!]!

  """
  fetch aggregated fields from the table: "allowed_role"
  """
  allowedRoleAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): AllowedRoleAggregate!

  """
  fetch data from the table: "allowed_role" using primary key columns
  """
  allowedRoleByPk(role: RolesEnum!, userId: uuid!): AllowedRole

  """
  An array relationship
  """
  bookmarks(
    """
    distinct select on columns
    """
    distinctOn: [BookmarksSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BookmarksOrderBy!]

    """
    filter the rows returned
    """
    where: BookmarksBoolExp
  ): [Bookmarks!]!

  """
  An aggregate relationship
  """
  bookmarksAggregate(
    """
    distinct select on columns
    """
    distinctOn: [BookmarksSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BookmarksOrderBy!]

    """
    filter the rows returned
    """
    where: BookmarksBoolExp
  ): BookmarksAggregate!

  """
  fetch data from the table: "bookmarks" using primary key columns
  """
  bookmarksByPk(id: uuid!): Bookmarks

  """
  fetch data from the table: "roles"
  """
  roles(
    """
    distinct select on columns
    """
    distinctOn: [RolesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [RolesOrderBy!]

    """
    filter the rows returned
    """
    where: RolesBoolExp
  ): [Roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [RolesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [RolesOrderBy!]

    """
    filter the rows returned
    """
    where: RolesBoolExp
  ): RolesAggregate!

  """
  fetch data from the table: "roles" using primary key columns
  """
  rolesByPk(value: String!): Roles

  """
  fetch data from the table: "session"
  """
  session(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): [Session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  sessionAggregate(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): SessionAggregate!

  """
  fetch data from the table: "session" using primary key columns
  """
  sessionByPk(id: uuid!): Session

  """
  fetch data from the table: "traefikRoutes"
  """
  traefikRoutes(
    """
    distinct select on columns
    """
    distinctOn: [TraefikRoutesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [TraefikRoutesOrderBy!]

    """
    filter the rows returned
    """
    where: TraefikRoutesBoolExp
  ): [TraefikRoutes!]!

  """
  fetch aggregated fields from the table: "traefikRoutes"
  """
  traefikRoutesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [TraefikRoutesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [TraefikRoutesOrderBy!]

    """
    filter the rows returned
    """
    where: TraefikRoutesBoolExp
  ): TraefikRoutesAggregate!

  """
  fetch data from the table: "traefikRoutes" using primary key columns
  """
  traefikRoutesByPk(name: String!): TraefikRoutes

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): UserAggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  userByPk(id: uuid!): User

  """
  fetch data from the table: "verification_token"
  """
  verificationToken(
    """
    distinct select on columns
    """
    distinctOn: [VerificationTokenSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [VerificationTokenOrderBy!]

    """
    filter the rows returned
    """
    where: VerificationTokenBoolExp
  ): [VerificationToken!]!

  """
  fetch aggregated fields from the table: "verification_token"
  """
  verificationTokenAggregate(
    """
    distinct select on columns
    """
    distinctOn: [VerificationTokenSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [VerificationTokenOrderBy!]

    """
    filter the rows returned
    """
    where: VerificationTokenBoolExp
  ): VerificationTokenAggregate!

  """
  fetch data from the table: "verification_token" using primary key columns
  """
  verificationTokenByPk(token: String!): VerificationToken
}

input sessionAggregateBoolExpCount {
  arguments: [SessionSelectColumn!]
  distinct: Boolean
  filter: SessionBoolExp
  predicate: IntComparisonExp!
}

type subscription_root {
  """
  fetch data from the table: "account"
  """
  account(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): [Account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  accountAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AccountSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AccountOrderBy!]

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): AccountAggregate!

  """
  fetch data from the table: "account" using primary key columns
  """
  accountByPk(id: uuid!): Account

  """
  fetch data from the table in a streaming manner: "account"
  """
  accountStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [AccountStreamCursorInput]!

    """
    filter the rows returned
    """
    where: AccountBoolExp
  ): [Account!]!

  """
  fetch data from the table: "allowed_role"
  """
  allowedRole(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): [AllowedRole!]!

  """
  fetch aggregated fields from the table: "allowed_role"
  """
  allowedRoleAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AllowedRoleSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AllowedRoleOrderBy!]

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): AllowedRoleAggregate!

  """
  fetch data from the table: "allowed_role" using primary key columns
  """
  allowedRoleByPk(role: RolesEnum!, userId: uuid!): AllowedRole

  """
  fetch data from the table in a streaming manner: "allowed_role"
  """
  allowedRoleStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [AllowedRoleStreamCursorInput]!

    """
    filter the rows returned
    """
    where: AllowedRoleBoolExp
  ): [AllowedRole!]!

  """
  An array relationship
  """
  bookmarks(
    """
    distinct select on columns
    """
    distinctOn: [BookmarksSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BookmarksOrderBy!]

    """
    filter the rows returned
    """
    where: BookmarksBoolExp
  ): [Bookmarks!]!

  """
  An aggregate relationship
  """
  bookmarksAggregate(
    """
    distinct select on columns
    """
    distinctOn: [BookmarksSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [BookmarksOrderBy!]

    """
    filter the rows returned
    """
    where: BookmarksBoolExp
  ): BookmarksAggregate!

  """
  fetch data from the table: "bookmarks" using primary key columns
  """
  bookmarksByPk(id: uuid!): Bookmarks

  """
  fetch data from the table in a streaming manner: "bookmarks"
  """
  bookmarksStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [BookmarksStreamCursorInput]!

    """
    filter the rows returned
    """
    where: BookmarksBoolExp
  ): [Bookmarks!]!

  """
  fetch data from the table: "roles"
  """
  roles(
    """
    distinct select on columns
    """
    distinctOn: [RolesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [RolesOrderBy!]

    """
    filter the rows returned
    """
    where: RolesBoolExp
  ): [Roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [RolesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [RolesOrderBy!]

    """
    filter the rows returned
    """
    where: RolesBoolExp
  ): RolesAggregate!

  """
  fetch data from the table: "roles" using primary key columns
  """
  rolesByPk(value: String!): Roles

  """
  fetch data from the table in a streaming manner: "roles"
  """
  rolesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [RolesStreamCursorInput]!

    """
    filter the rows returned
    """
    where: RolesBoolExp
  ): [Roles!]!

  """
  fetch data from the table: "session"
  """
  session(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): [Session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  sessionAggregate(
    """
    distinct select on columns
    """
    distinctOn: [SessionSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [SessionOrderBy!]

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): SessionAggregate!

  """
  fetch data from the table: "session" using primary key columns
  """
  sessionByPk(id: uuid!): Session

  """
  fetch data from the table in a streaming manner: "session"
  """
  sessionStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [SessionStreamCursorInput]!

    """
    filter the rows returned
    """
    where: SessionBoolExp
  ): [Session!]!

  """
  fetch data from the table: "traefikRoutes"
  """
  traefikRoutes(
    """
    distinct select on columns
    """
    distinctOn: [TraefikRoutesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [TraefikRoutesOrderBy!]

    """
    filter the rows returned
    """
    where: TraefikRoutesBoolExp
  ): [TraefikRoutes!]!

  """
  fetch aggregated fields from the table: "traefikRoutes"
  """
  traefikRoutesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [TraefikRoutesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [TraefikRoutesOrderBy!]

    """
    filter the rows returned
    """
    where: TraefikRoutesBoolExp
  ): TraefikRoutesAggregate!

  """
  fetch data from the table: "traefikRoutes" using primary key columns
  """
  traefikRoutesByPk(name: String!): TraefikRoutes

  """
  fetch data from the table in a streaming manner: "traefikRoutes"
  """
  traefikRoutesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [TraefikRoutesStreamCursorInput]!

    """
    filter the rows returned
    """
    where: TraefikRoutesBoolExp
  ): [TraefikRoutes!]!

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UserSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UserOrderBy!]

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): UserAggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  userByPk(id: uuid!): User

  """
  fetch data from the table in a streaming manner: "user"
  """
  userStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [UserStreamCursorInput]!

    """
    filter the rows returned
    """
    where: UserBoolExp
  ): [User!]!

  """
  fetch data from the table: "verification_token"
  """
  verificationToken(
    """
    distinct select on columns
    """
    distinctOn: [VerificationTokenSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [VerificationTokenOrderBy!]

    """
    filter the rows returned
    """
    where: VerificationTokenBoolExp
  ): [VerificationToken!]!

  """
  fetch aggregated fields from the table: "verification_token"
  """
  verificationTokenAggregate(
    """
    distinct select on columns
    """
    distinctOn: [VerificationTokenSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [VerificationTokenOrderBy!]

    """
    filter the rows returned
    """
    where: VerificationTokenBoolExp
  ): VerificationTokenAggregate!

  """
  fetch data from the table: "verification_token" using primary key columns
  """
  verificationTokenByPk(token: String!): VerificationToken

  """
  fetch data from the table in a streaming manner: "verification_token"
  """
  verificationTokenStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [VerificationTokenStreamCursorInput]!

    """
    filter the rows returned
    """
    where: VerificationTokenBoolExp
  ): [VerificationToken!]!
}

scalar timestamptz

input userAggregateBoolExpBool_and {
  arguments: UserSelectColumnUserAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: UserBoolExp
  predicate: BooleanComparisonExp!
}

input userAggregateBoolExpBool_or {
  arguments: UserSelectColumnUserAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: UserBoolExp
  predicate: BooleanComparisonExp!
}

input userAggregateBoolExpCount {
  arguments: [UserSelectColumn!]
  distinct: Boolean
  filter: UserBoolExp
  predicate: IntComparisonExp!
}

scalar uuid
