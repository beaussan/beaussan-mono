schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
columns and relationships of "accounts"
"""
type Accounts {
  accessToken: String
  accessTokenExpires: timestamptz
  compoundId: String!
  createdAt: timestamptz!
  id: uuid!
  providerAccountId: String!
  providerId: String!
  providerType: String!
  refreshToken: String
  updatedAt: timestamptz!

  """An object relationship"""
  user: User!
  userId: uuid!
}

"""
aggregated selection of "accounts"
"""
type AccountsAggregate {
  aggregate: AccountsAggregateFields
  nodes: [Accounts!]!
}

input AccountsAggregateBoolExp {
  count: accountsAggregateBoolExpCount
}

"""
aggregate fields of "accounts"
"""
type AccountsAggregateFields {
  count(columns: [AccountsSelectColumn!], distinct: Boolean): Int!
  max: AccountsMaxFields
  min: AccountsMinFields
}

"""
order by aggregate values of table "accounts"
"""
input AccountsAggregateOrderBy {
  count: OrderBy
  max: AccountsMaxOrderBy
  min: AccountsMinOrderBy
}

"""
input type for inserting array relation for remote table "accounts"
"""
input AccountsArrRelInsertInput {
  data: [AccountsInsertInput!]!

  """upsert condition"""
  onConflict: AccountsOnConflict
}

"""
Boolean expression to filter rows from the table "accounts". All fields are combined with a logical 'AND'.
"""
input AccountsBoolExp {
  _and: [AccountsBoolExp!]
  _not: AccountsBoolExp
  _or: [AccountsBoolExp!]
  accessToken: StringComparisonExp
  accessTokenExpires: TimestamptzComparisonExp
  compoundId: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  providerAccountId: StringComparisonExp
  providerId: StringComparisonExp
  providerType: StringComparisonExp
  refreshToken: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "accounts"
"""
enum AccountsConstraint {
  """
  unique or primary key constraint on columns "compound_id"
  """
  accounts_compound_id_key

  """
  unique or primary key constraint on columns "id"
  """
  accounts_pkey
}

"""
input type for inserting data into table "accounts"
"""
input AccountsInsertInput {
  accessToken: String
  accessTokenExpires: timestamptz
  compoundId: String
  createdAt: timestamptz
  id: uuid
  providerAccountId: String
  providerId: String
  providerType: String
  refreshToken: String
  updatedAt: timestamptz
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type AccountsMaxFields {
  accessToken: String
  accessTokenExpires: timestamptz
  compoundId: String
  createdAt: timestamptz
  id: uuid
  providerAccountId: String
  providerId: String
  providerType: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "accounts"
"""
input AccountsMaxOrderBy {
  accessToken: OrderBy
  accessTokenExpires: OrderBy
  compoundId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  providerAccountId: OrderBy
  providerId: OrderBy
  providerType: OrderBy
  refreshToken: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type AccountsMinFields {
  accessToken: String
  accessTokenExpires: timestamptz
  compoundId: String
  createdAt: timestamptz
  id: uuid
  providerAccountId: String
  providerId: String
  providerType: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "accounts"
"""
input AccountsMinOrderBy {
  accessToken: OrderBy
  accessTokenExpires: OrderBy
  compoundId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  providerAccountId: OrderBy
  providerId: OrderBy
  providerType: OrderBy
  refreshToken: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "accounts"
"""
type AccountsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Accounts!]!
}

"""
on_conflict condition type for table "accounts"
"""
input AccountsOnConflict {
  constraint: AccountsConstraint!
  updateColumns: [AccountsUpdateColumn!]! = []
  where: AccountsBoolExp
}

"""Ordering options when selecting data from "accounts"."""
input AccountsOrderBy {
  accessToken: OrderBy
  accessTokenExpires: OrderBy
  compoundId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  providerAccountId: OrderBy
  providerId: OrderBy
  providerType: OrderBy
  refreshToken: OrderBy
  updatedAt: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: accounts"""
input AccountsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "accounts"
"""
enum AccountsSelectColumn {
  """column name"""
  accessToken

  """column name"""
  accessTokenExpires

  """column name"""
  compoundId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerAccountId

  """column name"""
  providerId

  """column name"""
  providerType

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "accounts"
"""
input AccountsSetInput {
  accessToken: String
  accessTokenExpires: timestamptz
  compoundId: String
  createdAt: timestamptz
  id: uuid
  providerAccountId: String
  providerId: String
  providerType: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "accounts"
"""
input AccountsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AccountsStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AccountsStreamCursorValueInput {
  accessToken: String
  accessTokenExpires: timestamptz
  compoundId: String
  createdAt: timestamptz
  id: uuid
  providerAccountId: String
  providerId: String
  providerType: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "accounts"
"""
enum AccountsUpdateColumn {
  """column name"""
  accessToken

  """column name"""
  accessTokenExpires

  """column name"""
  compoundId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerAccountId

  """column name"""
  providerId

  """column name"""
  providerType

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

input AccountsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: AccountsSetInput

  """filter the rows which have to be updated"""
  where: AccountsBoolExp!
}

"""
columns and relationships of "allowed_roles"
"""
type AllowedRoles {
  role: String!

  """An object relationship"""
  roleByRole: Roles!

  """An object relationship"""
  user: User!
  userId: uuid!
}

"""
aggregated selection of "allowed_roles"
"""
type AllowedRolesAggregate {
  aggregate: AllowedRolesAggregateFields
  nodes: [AllowedRoles!]!
}

input AllowedRolesAggregateBoolExp {
  count: allowedRolesAggregateBoolExpCount
}

"""
aggregate fields of "allowed_roles"
"""
type AllowedRolesAggregateFields {
  count(columns: [AllowedRolesSelectColumn!], distinct: Boolean): Int!
  max: AllowedRolesMaxFields
  min: AllowedRolesMinFields
}

"""
order by aggregate values of table "allowed_roles"
"""
input AllowedRolesAggregateOrderBy {
  count: OrderBy
  max: AllowedRolesMaxOrderBy
  min: AllowedRolesMinOrderBy
}

"""
input type for inserting array relation for remote table "allowed_roles"
"""
input AllowedRolesArrRelInsertInput {
  data: [AllowedRolesInsertInput!]!

  """upsert condition"""
  onConflict: AllowedRolesOnConflict
}

"""
Boolean expression to filter rows from the table "allowed_roles". All fields are combined with a logical 'AND'.
"""
input AllowedRolesBoolExp {
  _and: [AllowedRolesBoolExp!]
  _not: AllowedRolesBoolExp
  _or: [AllowedRolesBoolExp!]
  role: StringComparisonExp
  roleByRole: RolesBoolExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "allowed_roles"
"""
enum AllowedRolesConstraint {
  """
  unique or primary key constraint on columns "user_id", "role"
  """
  allowed_roles_pkey
}

"""
input type for inserting data into table "allowed_roles"
"""
input AllowedRolesInsertInput {
  role: String
  roleByRole: RolesObjRelInsertInput
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type AllowedRolesMaxFields {
  role: String
  userId: uuid
}

"""
order by max() on columns of table "allowed_roles"
"""
input AllowedRolesMaxOrderBy {
  role: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type AllowedRolesMinFields {
  role: String
  userId: uuid
}

"""
order by min() on columns of table "allowed_roles"
"""
input AllowedRolesMinOrderBy {
  role: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "allowed_roles"
"""
type AllowedRolesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [AllowedRoles!]!
}

"""
on_conflict condition type for table "allowed_roles"
"""
input AllowedRolesOnConflict {
  constraint: AllowedRolesConstraint!
  updateColumns: [AllowedRolesUpdateColumn!]! = []
  where: AllowedRolesBoolExp
}

"""Ordering options when selecting data from "allowed_roles"."""
input AllowedRolesOrderBy {
  role: OrderBy
  roleByRole: RolesOrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: allowed_roles"""
input AllowedRolesPkColumnsInput {
  role: String!
  userId: uuid!
}

"""
select columns of table "allowed_roles"
"""
enum AllowedRolesSelectColumn {
  """column name"""
  role

  """column name"""
  userId
}

"""
input type for updating data in table "allowed_roles"
"""
input AllowedRolesSetInput {
  role: String
  userId: uuid
}

"""
Streaming cursor of the table "allowed_roles"
"""
input AllowedRolesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AllowedRolesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AllowedRolesStreamCursorValueInput {
  role: String
  userId: uuid
}

"""
update columns of table "allowed_roles"
"""
enum AllowedRolesUpdateColumn {
  """column name"""
  role

  """column name"""
  userId
}

input AllowedRolesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: AllowedRolesSetInput

  """filter the rows which have to be updated"""
  where: AllowedRolesBoolExp!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type CommitItem {
  author_profile_picture: String
  commit_author_date: String
  commit_author_email: String
  commit_author_name: String
  commit_committer_date: String
  commit_committer_email: String
  commit_committer_name: String
  commit_message: String
  commit_tree_created: String
  commit_tree_sha: String
  commit_tree_url: String
  commit_url: String
  created: String
  html_url: String
  parents: jsonb
  sha: String
  url: String
}

"""
columns and relationships of "course"
"""
type Course {
  canStudentSeeFeedback: Boolean!
  canStudentSeeGrade: Boolean!
  createdAt: timestamptz!
  id: uuid!
  name: String!

  """An array relationship"""
  practiceToCourses(
    """distinct select on columns"""
    distinctOn: [PracticeToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToCourseOrderBy!]

    """filter the rows returned"""
    where: PracticeToCourseBoolExp
  ): [PracticeToCourse!]!

  """An aggregate relationship"""
  practiceToCoursesAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToCourseOrderBy!]

    """filter the rows returned"""
    where: PracticeToCourseBoolExp
  ): PracticeToCourseAggregate!

  """An array relationship"""
  studentToCourses(
    """distinct select on columns"""
    distinctOn: [StudentToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentToCourseOrderBy!]

    """filter the rows returned"""
    where: StudentToCourseBoolExp
  ): [StudentToCourse!]!

  """An aggregate relationship"""
  studentToCoursesAggregate(
    """distinct select on columns"""
    distinctOn: [StudentToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentToCourseOrderBy!]

    """filter the rows returned"""
    where: StudentToCourseBoolExp
  ): StudentToCourseAggregate!
  updatedAt: timestamptz!
  years: String!
}

"""
aggregated selection of "course"
"""
type CourseAggregate {
  aggregate: CourseAggregateFields
  nodes: [Course!]!
}

"""
aggregate fields of "course"
"""
type CourseAggregateFields {
  count(columns: [CourseSelectColumn!], distinct: Boolean): Int!
  max: CourseMaxFields
  min: CourseMinFields
}

"""
Boolean expression to filter rows from the table "course". All fields are combined with a logical 'AND'.
"""
input CourseBoolExp {
  _and: [CourseBoolExp!]
  _not: CourseBoolExp
  _or: [CourseBoolExp!]
  canStudentSeeFeedback: BooleanComparisonExp
  canStudentSeeGrade: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  practiceToCourses: PracticeToCourseBoolExp
  practiceToCoursesAggregate: PracticeToCourseAggregateBoolExp
  studentToCourses: StudentToCourseBoolExp
  studentToCoursesAggregate: StudentToCourseAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  years: StringComparisonExp
}

"""
unique or primary key constraints on table "course"
"""
enum CourseConstraint {
  """
  unique or primary key constraint on columns "years", "name"
  """
  promotion_name_years_key

  """
  unique or primary key constraint on columns "id"
  """
  promotion_pkey
}

"""
input type for inserting data into table "course"
"""
input CourseInsertInput {
  canStudentSeeFeedback: Boolean
  canStudentSeeGrade: Boolean
  createdAt: timestamptz
  id: uuid
  name: String
  practiceToCourses: PracticeToCourseArrRelInsertInput
  studentToCourses: StudentToCourseArrRelInsertInput
  updatedAt: timestamptz
  years: String
}

"""aggregate max on columns"""
type CourseMaxFields {
  createdAt: timestamptz
  id: uuid
  name: String
  updatedAt: timestamptz
  years: String
}

"""aggregate min on columns"""
type CourseMinFields {
  createdAt: timestamptz
  id: uuid
  name: String
  updatedAt: timestamptz
  years: String
}

"""
response of any mutation on the table "course"
"""
type CourseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Course!]!
}

"""
input type for inserting object relation for remote table "course"
"""
input CourseObjRelInsertInput {
  data: CourseInsertInput!

  """upsert condition"""
  onConflict: CourseOnConflict
}

"""
on_conflict condition type for table "course"
"""
input CourseOnConflict {
  constraint: CourseConstraint!
  updateColumns: [CourseUpdateColumn!]! = []
  where: CourseBoolExp
}

"""Ordering options when selecting data from "course"."""
input CourseOrderBy {
  canStudentSeeFeedback: OrderBy
  canStudentSeeGrade: OrderBy
  createdAt: OrderBy
  id: OrderBy
  name: OrderBy
  practiceToCoursesAggregate: PracticeToCourseAggregateOrderBy
  studentToCoursesAggregate: StudentToCourseAggregateOrderBy
  updatedAt: OrderBy
  years: OrderBy
}

"""primary key columns input for table: course"""
input CoursePkColumnsInput {
  id: uuid!
}

"""
select columns of table "course"
"""
enum CourseSelectColumn {
  """column name"""
  canStudentSeeFeedback

  """column name"""
  canStudentSeeGrade

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updatedAt

  """column name"""
  years
}

"""
input type for updating data in table "course"
"""
input CourseSetInput {
  canStudentSeeFeedback: Boolean
  canStudentSeeGrade: Boolean
  createdAt: timestamptz
  id: uuid
  name: String
  updatedAt: timestamptz
  years: String
}

"""
Streaming cursor of the table "course"
"""
input CourseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseStreamCursorValueInput {
  canStudentSeeFeedback: Boolean
  canStudentSeeGrade: Boolean
  createdAt: timestamptz
  id: uuid
  name: String
  updatedAt: timestamptz
  years: String
}

"""
update columns of table "course"
"""
enum CourseUpdateColumn {
  """column name"""
  canStudentSeeFeedback

  """column name"""
  canStudentSeeGrade

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updatedAt

  """column name"""
  years
}

input CourseUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: CourseSetInput

  """filter the rows which have to be updated"""
  where: CourseBoolExp!
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

type FillEmptyYieldsOutput {
  affected_rows: Int!
}

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input Float8ComparisonExp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _isNull: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

type GetGitFileDataOutput {
  content: String
  download_url: String
  encoding: String
  git_url: String
  html_url: String
  name: String
  path: String
  practice_to_student_yield_id: uuid!
  practice_yield_expected_output_id: uuid!
  sha: String
  size: Int
  submodule_git_url: String
  target: String
  type: String
  url: String
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """is the column contained in the given json value"""
  _containedIn: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _hasKey: String

  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input NumericComparisonExp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _isNull: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
columns and relationships of "practice"
"""
type Practice {
  createdAt: timestamptz!
  description: String
  id: uuid!

  """An array relationship"""
  practiceToCourses(
    """distinct select on columns"""
    distinctOn: [PracticeToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToCourseOrderBy!]

    """filter the rows returned"""
    where: PracticeToCourseBoolExp
  ): [PracticeToCourse!]!

  """An aggregate relationship"""
  practiceToCoursesAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToCourseOrderBy!]

    """filter the rows returned"""
    where: PracticeToCourseBoolExp
  ): PracticeToCourseAggregate!

  """An array relationship"""
  practiceYields(
    """distinct select on columns"""
    distinctOn: [PracticeYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldBoolExp
  ): [PracticeYield!]!

  """An aggregate relationship"""
  practiceYieldsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldBoolExp
  ): PracticeYieldAggregate!
  title: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "practice"
"""
type PracticeAggregate {
  aggregate: PracticeAggregateFields
  nodes: [Practice!]!
}

"""
aggregate fields of "practice"
"""
type PracticeAggregateFields {
  count(columns: [PracticeSelectColumn!], distinct: Boolean): Int!
  max: PracticeMaxFields
  min: PracticeMinFields
}

"""
Boolean expression to filter rows from the table "practice". All fields are combined with a logical 'AND'.
"""
input PracticeBoolExp {
  _and: [PracticeBoolExp!]
  _not: PracticeBoolExp
  _or: [PracticeBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  practiceToCourses: PracticeToCourseBoolExp
  practiceToCoursesAggregate: PracticeToCourseAggregateBoolExp
  practiceYields: PracticeYieldBoolExp
  practiceYieldsAggregate: PracticeYieldAggregateBoolExp
  title: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "practice"
"""
enum PracticeConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  practice_pkey

  """
  unique or primary key constraint on columns "title"
  """
  practice_title_key
}

"""
input type for inserting data into table "practice"
"""
input PracticeInsertInput {
  createdAt: timestamptz
  description: String
  id: uuid
  practiceToCourses: PracticeToCourseArrRelInsertInput
  practiceYields: PracticeYieldArrRelInsertInput
  title: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PracticeMaxFields {
  createdAt: timestamptz
  description: String
  id: uuid
  title: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type PracticeMinFields {
  createdAt: timestamptz
  description: String
  id: uuid
  title: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "practice"
"""
type PracticeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Practice!]!
}

"""
input type for inserting object relation for remote table "practice"
"""
input PracticeObjRelInsertInput {
  data: PracticeInsertInput!

  """upsert condition"""
  onConflict: PracticeOnConflict
}

"""
on_conflict condition type for table "practice"
"""
input PracticeOnConflict {
  constraint: PracticeConstraint!
  updateColumns: [PracticeUpdateColumn!]! = []
  where: PracticeBoolExp
}

"""Ordering options when selecting data from "practice"."""
input PracticeOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  practiceToCoursesAggregate: PracticeToCourseAggregateOrderBy
  practiceYieldsAggregate: PracticeYieldAggregateOrderBy
  title: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: practice"""
input PracticePkColumnsInput {
  id: uuid!
}

"""
select columns of table "practice"
"""
enum PracticeSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  title

  """column name"""
  updatedAt
}

"""
input type for updating data in table "practice"
"""
input PracticeSetInput {
  createdAt: timestamptz
  description: String
  id: uuid
  title: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "practice"
"""
input PracticeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  id: uuid
  title: String
  updatedAt: timestamptz
}

"""
columns and relationships of "practice_to_course"
"""
type PracticeToCourse {
  closeDate: timestamptz

  """An object relationship"""
  course: Course!
  courseId: uuid!
  createdAt: timestamptz!
  giteaOrgName: String
  id: uuid!
  is_open: Boolean
  openDate: timestamptz

  """An object relationship"""
  practice: Practice!
  practiceId: uuid!

  """An array relationship"""
  practiceToStudents(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentBoolExp
  ): [PracticeToStudent!]!

  """An aggregate relationship"""
  practiceToStudentsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentBoolExp
  ): PracticeToStudentAggregate!
  updatedAt: timestamptz!
}

"""
aggregated selection of "practice_to_course"
"""
type PracticeToCourseAggregate {
  aggregate: PracticeToCourseAggregateFields
  nodes: [PracticeToCourse!]!
}

input PracticeToCourseAggregateBoolExp {
  count: practiceToCourseAggregateBoolExpCount
}

"""
aggregate fields of "practice_to_course"
"""
type PracticeToCourseAggregateFields {
  count(columns: [PracticeToCourseSelectColumn!], distinct: Boolean): Int!
  max: PracticeToCourseMaxFields
  min: PracticeToCourseMinFields
}

"""
order by aggregate values of table "practice_to_course"
"""
input PracticeToCourseAggregateOrderBy {
  count: OrderBy
  max: PracticeToCourseMaxOrderBy
  min: PracticeToCourseMinOrderBy
}

"""
input type for inserting array relation for remote table "practice_to_course"
"""
input PracticeToCourseArrRelInsertInput {
  data: [PracticeToCourseInsertInput!]!

  """upsert condition"""
  onConflict: PracticeToCourseOnConflict
}

"""
Boolean expression to filter rows from the table "practice_to_course". All fields are combined with a logical 'AND'.
"""
input PracticeToCourseBoolExp {
  _and: [PracticeToCourseBoolExp!]
  _not: PracticeToCourseBoolExp
  _or: [PracticeToCourseBoolExp!]
  closeDate: TimestamptzComparisonExp
  course: CourseBoolExp
  courseId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  giteaOrgName: StringComparisonExp
  id: UuidComparisonExp
  is_open: BooleanComparisonExp
  openDate: TimestamptzComparisonExp
  practice: PracticeBoolExp
  practiceId: UuidComparisonExp
  practiceToStudents: PracticeToStudentBoolExp
  practiceToStudentsAggregate: PracticeToStudentAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "practice_to_course"
"""
enum PracticeToCourseConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  practice_to_promotion_pkey

  """
  unique or primary key constraint on columns "course_id", "practice_id"
  """
  practice_to_promotion_promotion_id_practice_id_key
}

"""
input type for inserting data into table "practice_to_course"
"""
input PracticeToCourseInsertInput {
  closeDate: timestamptz
  course: CourseObjRelInsertInput
  courseId: uuid
  createdAt: timestamptz
  giteaOrgName: String
  id: uuid
  openDate: timestamptz
  practice: PracticeObjRelInsertInput
  practiceId: uuid
  practiceToStudents: PracticeToStudentArrRelInsertInput
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PracticeToCourseMaxFields {
  closeDate: timestamptz
  courseId: uuid
  createdAt: timestamptz
  giteaOrgName: String
  id: uuid
  openDate: timestamptz
  practiceId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "practice_to_course"
"""
input PracticeToCourseMaxOrderBy {
  closeDate: OrderBy
  courseId: OrderBy
  createdAt: OrderBy
  giteaOrgName: OrderBy
  id: OrderBy
  openDate: OrderBy
  practiceId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PracticeToCourseMinFields {
  closeDate: timestamptz
  courseId: uuid
  createdAt: timestamptz
  giteaOrgName: String
  id: uuid
  openDate: timestamptz
  practiceId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "practice_to_course"
"""
input PracticeToCourseMinOrderBy {
  closeDate: OrderBy
  courseId: OrderBy
  createdAt: OrderBy
  giteaOrgName: OrderBy
  id: OrderBy
  openDate: OrderBy
  practiceId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "practice_to_course"
"""
type PracticeToCourseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeToCourse!]!
}

"""
input type for inserting object relation for remote table "practice_to_course"
"""
input PracticeToCourseObjRelInsertInput {
  data: PracticeToCourseInsertInput!

  """upsert condition"""
  onConflict: PracticeToCourseOnConflict
}

"""
on_conflict condition type for table "practice_to_course"
"""
input PracticeToCourseOnConflict {
  constraint: PracticeToCourseConstraint!
  updateColumns: [PracticeToCourseUpdateColumn!]! = []
  where: PracticeToCourseBoolExp
}

"""Ordering options when selecting data from "practice_to_course"."""
input PracticeToCourseOrderBy {
  closeDate: OrderBy
  course: CourseOrderBy
  courseId: OrderBy
  createdAt: OrderBy
  giteaOrgName: OrderBy
  id: OrderBy
  is_open: OrderBy
  openDate: OrderBy
  practice: PracticeOrderBy
  practiceId: OrderBy
  practiceToStudentsAggregate: PracticeToStudentAggregateOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: practice_to_course"""
input PracticeToCoursePkColumnsInput {
  id: uuid!
}

"""
select columns of table "practice_to_course"
"""
enum PracticeToCourseSelectColumn {
  """column name"""
  closeDate

  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  giteaOrgName

  """column name"""
  id

  """column name"""
  openDate

  """column name"""
  practiceId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "practice_to_course"
"""
input PracticeToCourseSetInput {
  closeDate: timestamptz
  courseId: uuid
  createdAt: timestamptz
  giteaOrgName: String
  id: uuid
  openDate: timestamptz
  practiceId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "practice_to_course"
"""
input PracticeToCourseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeToCourseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeToCourseStreamCursorValueInput {
  closeDate: timestamptz
  courseId: uuid
  createdAt: timestamptz
  giteaOrgName: String
  id: uuid
  openDate: timestamptz
  practiceId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "practice_to_course"
"""
enum PracticeToCourseUpdateColumn {
  """column name"""
  closeDate

  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  giteaOrgName

  """column name"""
  id

  """column name"""
  openDate

  """column name"""
  practiceId

  """column name"""
  updatedAt
}

input PracticeToCourseUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PracticeToCourseSetInput

  """filter the rows which have to be updated"""
  where: PracticeToCourseBoolExp!
}

"""
columns and relationships of "practice_to_student"
"""
type PracticeToStudent {
  coursePracticeId: uuid!
  createdAt: timestamptz!
  feedback(
    """JSON select path"""
    path: String
  ): jsonb
  grade: float8
  gradeDetail(
    """JSON select path"""
    path: String
  ): jsonb
  graded: Boolean!
  id: uuid!

  """An object relationship"""
  practiceToCourse: PracticeToCourse!

  """An array relationship"""
  practiceToStudentYields(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentYieldBoolExp
  ): [PracticeToStudentYield!]!

  """An aggregate relationship"""
  practiceToStudentYieldsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentYieldBoolExp
  ): PracticeToStudentYieldAggregate!

  """An object relationship"""
  student: Student!
  studentId: uuid!
  submited: Boolean!
  updatedAt: timestamptz!
}

"""
aggregated selection of "practice_to_student"
"""
type PracticeToStudentAggregate {
  aggregate: PracticeToStudentAggregateFields
  nodes: [PracticeToStudent!]!
}

input PracticeToStudentAggregateBoolExp {
  avg: practiceToStudentAggregateBoolExpAvg
  bool_and: practiceToStudentAggregateBoolExpBool_and
  bool_or: practiceToStudentAggregateBoolExpBool_or
  corr: practiceToStudentAggregateBoolExpCorr
  count: practiceToStudentAggregateBoolExpCount
  covar_samp: practiceToStudentAggregateBoolExpCovar_samp
  max: practiceToStudentAggregateBoolExpMax
  min: practiceToStudentAggregateBoolExpMin
  stddev_samp: practiceToStudentAggregateBoolExpStddev_samp
  sum: practiceToStudentAggregateBoolExpSum
  var_samp: practiceToStudentAggregateBoolExpVar_samp
}

"""
aggregate fields of "practice_to_student"
"""
type PracticeToStudentAggregateFields {
  avg: PracticeToStudentAvgFields
  count(columns: [PracticeToStudentSelectColumn!], distinct: Boolean): Int!
  max: PracticeToStudentMaxFields
  min: PracticeToStudentMinFields
  stddev: PracticeToStudentStddevFields
  stddevPop: PracticeToStudentStddevPopFields
  stddevSamp: PracticeToStudentStddevSampFields
  sum: PracticeToStudentSumFields
  varPop: PracticeToStudentVarPopFields
  varSamp: PracticeToStudentVarSampFields
  variance: PracticeToStudentVarianceFields
}

"""
order by aggregate values of table "practice_to_student"
"""
input PracticeToStudentAggregateOrderBy {
  avg: PracticeToStudentAvgOrderBy
  count: OrderBy
  max: PracticeToStudentMaxOrderBy
  min: PracticeToStudentMinOrderBy
  stddev: PracticeToStudentStddevOrderBy
  stddevPop: PracticeToStudentStddevPopOrderBy
  stddevSamp: PracticeToStudentStddevSampOrderBy
  sum: PracticeToStudentSumOrderBy
  varPop: PracticeToStudentVarPopOrderBy
  varSamp: PracticeToStudentVarSampOrderBy
  variance: PracticeToStudentVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input PracticeToStudentAppendInput {
  feedback: jsonb
  gradeDetail: jsonb
}

"""
input type for inserting array relation for remote table "practice_to_student"
"""
input PracticeToStudentArrRelInsertInput {
  data: [PracticeToStudentInsertInput!]!

  """upsert condition"""
  onConflict: PracticeToStudentOnConflict
}

"""aggregate avg on columns"""
type PracticeToStudentAvgFields {
  grade: Float
}

"""
order by avg() on columns of table "practice_to_student"
"""
input PracticeToStudentAvgOrderBy {
  grade: OrderBy
}

"""
Boolean expression to filter rows from the table "practice_to_student". All fields are combined with a logical 'AND'.
"""
input PracticeToStudentBoolExp {
  _and: [PracticeToStudentBoolExp!]
  _not: PracticeToStudentBoolExp
  _or: [PracticeToStudentBoolExp!]
  coursePracticeId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  feedback: JsonbComparisonExp
  grade: Float8ComparisonExp
  gradeDetail: JsonbComparisonExp
  graded: BooleanComparisonExp
  id: UuidComparisonExp
  practiceToCourse: PracticeToCourseBoolExp
  practiceToStudentYields: PracticeToStudentYieldBoolExp
  practiceToStudentYieldsAggregate: PracticeToStudentYieldAggregateBoolExp
  student: StudentBoolExp
  studentId: UuidComparisonExp
  submited: BooleanComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "practice_to_student"
"""
enum PracticeToStudentConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  practice_to_student_pkey

  """
  unique or primary key constraint on columns "student_id", "course_practice_id"
  """
  practice_to_student_student_id_promotion_practice_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input PracticeToStudentDeleteAtPathInput {
  feedback: [String!]
  gradeDetail: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input PracticeToStudentDeleteElemInput {
  feedback: Int
  gradeDetail: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input PracticeToStudentDeleteKeyInput {
  feedback: String
  gradeDetail: String
}

"""
columns and relationships of "practice_to_student_feedback"
"""
type PracticeToStudentFeedback {
  feedback(
    """JSON select path"""
    path: String
  ): jsonb
  practiceToStudentId: uuid

  """An object relationship"""
  practice_to_student: PracticeToStudent
}

"""
aggregated selection of "practice_to_student_feedback"
"""
type PracticeToStudentFeedbackAggregate {
  aggregate: PracticeToStudentFeedbackAggregateFields
  nodes: [PracticeToStudentFeedback!]!
}

"""
aggregate fields of "practice_to_student_feedback"
"""
type PracticeToStudentFeedbackAggregateFields {
  count(columns: [PracticeToStudentFeedbackSelectColumn!], distinct: Boolean): Int!
  max: PracticeToStudentFeedbackMaxFields
  min: PracticeToStudentFeedbackMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input PracticeToStudentFeedbackAppendInput {
  feedback: jsonb
}

"""
Boolean expression to filter rows from the table "practice_to_student_feedback". All fields are combined with a logical 'AND'.
"""
input PracticeToStudentFeedbackBoolExp {
  _and: [PracticeToStudentFeedbackBoolExp!]
  _not: PracticeToStudentFeedbackBoolExp
  _or: [PracticeToStudentFeedbackBoolExp!]
  feedback: JsonbComparisonExp
  practiceToStudentId: UuidComparisonExp
  practice_to_student: PracticeToStudentBoolExp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input PracticeToStudentFeedbackDeleteAtPathInput {
  feedback: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input PracticeToStudentFeedbackDeleteElemInput {
  feedback: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input PracticeToStudentFeedbackDeleteKeyInput {
  feedback: String
}

"""
input type for inserting data into table "practice_to_student_feedback"
"""
input PracticeToStudentFeedbackInsertInput {
  feedback: jsonb
  practiceToStudentId: uuid
  practice_to_student: PracticeToStudentObjRelInsertInput
}

"""aggregate max on columns"""
type PracticeToStudentFeedbackMaxFields {
  practiceToStudentId: uuid
}

"""aggregate min on columns"""
type PracticeToStudentFeedbackMinFields {
  practiceToStudentId: uuid
}

"""
response of any mutation on the table "practice_to_student_feedback"
"""
type PracticeToStudentFeedbackMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeToStudentFeedback!]!
}

"""
Ordering options when selecting data from "practice_to_student_feedback".
"""
input PracticeToStudentFeedbackOrderBy {
  feedback: OrderBy
  practiceToStudentId: OrderBy
  practice_to_student: PracticeToStudentOrderBy
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input PracticeToStudentFeedbackPrependInput {
  feedback: jsonb
}

"""
select columns of table "practice_to_student_feedback"
"""
enum PracticeToStudentFeedbackSelectColumn {
  """column name"""
  feedback

  """column name"""
  practiceToStudentId
}

"""
input type for updating data in table "practice_to_student_feedback"
"""
input PracticeToStudentFeedbackSetInput {
  feedback: jsonb
  practiceToStudentId: uuid
}

"""
Streaming cursor of the table "practice_to_student_feedback"
"""
input PracticeToStudentFeedbackStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeToStudentFeedbackStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeToStudentFeedbackStreamCursorValueInput {
  feedback: jsonb
  practiceToStudentId: uuid
}

input PracticeToStudentFeedbackUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: PracticeToStudentFeedbackAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: PracticeToStudentFeedbackDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: PracticeToStudentFeedbackDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: PracticeToStudentFeedbackDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: PracticeToStudentFeedbackPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: PracticeToStudentFeedbackSetInput

  """filter the rows which have to be updated"""
  where: PracticeToStudentFeedbackBoolExp!
}

"""
columns and relationships of "practice_to_student_grade"
"""
type PracticeToStudentGrade {
  grade: float8
  gradeDetail(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  practiceToStudent: PracticeToStudent
  practiceToStudentId: uuid
}

"""
aggregated selection of "practice_to_student_grade"
"""
type PracticeToStudentGradeAggregate {
  aggregate: PracticeToStudentGradeAggregateFields
  nodes: [PracticeToStudentGrade!]!
}

"""
aggregate fields of "practice_to_student_grade"
"""
type PracticeToStudentGradeAggregateFields {
  avg: PracticeToStudentGradeAvgFields
  count(columns: [PracticeToStudentGradeSelectColumn!], distinct: Boolean): Int!
  max: PracticeToStudentGradeMaxFields
  min: PracticeToStudentGradeMinFields
  stddev: PracticeToStudentGradeStddevFields
  stddevPop: PracticeToStudentGradeStddevPopFields
  stddevSamp: PracticeToStudentGradeStddevSampFields
  sum: PracticeToStudentGradeSumFields
  varPop: PracticeToStudentGradeVarPopFields
  varSamp: PracticeToStudentGradeVarSampFields
  variance: PracticeToStudentGradeVarianceFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input PracticeToStudentGradeAppendInput {
  gradeDetail: jsonb
}

"""aggregate avg on columns"""
type PracticeToStudentGradeAvgFields {
  grade: Float
}

"""
Boolean expression to filter rows from the table "practice_to_student_grade". All fields are combined with a logical 'AND'.
"""
input PracticeToStudentGradeBoolExp {
  _and: [PracticeToStudentGradeBoolExp!]
  _not: PracticeToStudentGradeBoolExp
  _or: [PracticeToStudentGradeBoolExp!]
  grade: Float8ComparisonExp
  gradeDetail: JsonbComparisonExp
  practiceToStudent: PracticeToStudentBoolExp
  practiceToStudentId: UuidComparisonExp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input PracticeToStudentGradeDeleteAtPathInput {
  gradeDetail: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input PracticeToStudentGradeDeleteElemInput {
  gradeDetail: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input PracticeToStudentGradeDeleteKeyInput {
  gradeDetail: String
}

"""
input type for incrementing numeric columns in table "practice_to_student_grade"
"""
input PracticeToStudentGradeIncInput {
  grade: float8
}

"""
input type for inserting data into table "practice_to_student_grade"
"""
input PracticeToStudentGradeInsertInput {
  grade: float8
  gradeDetail: jsonb
  practiceToStudent: PracticeToStudentObjRelInsertInput
  practiceToStudentId: uuid
}

"""aggregate max on columns"""
type PracticeToStudentGradeMaxFields {
  grade: float8
  practiceToStudentId: uuid
}

"""
columns and relationships of "practice_to_student_grade_metric"
"""
type PracticeToStudentGradeMetric {
  createdAt: timestamptz!
  feedback(
    """JSON select path"""
    path: String
  ): jsonb!
  id: uuid!
  percentGrade: numeric!

  """An object relationship"""
  practiceToStudentYield: PracticeToStudentYield!
  practiceToStudentYieldId: uuid!

  """An object relationship"""
  practiceYieldGradeMetric: PracticeYieldGradeMetric!
  practiceYieldGradeMetricId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "practice_to_student_grade_metric"
"""
type PracticeToStudentGradeMetricAggregate {
  aggregate: PracticeToStudentGradeMetricAggregateFields
  nodes: [PracticeToStudentGradeMetric!]!
}

input PracticeToStudentGradeMetricAggregateBoolExp {
  count: practiceToStudentGradeMetricAggregateBoolExpCount
}

"""
aggregate fields of "practice_to_student_grade_metric"
"""
type PracticeToStudentGradeMetricAggregateFields {
  avg: PracticeToStudentGradeMetricAvgFields
  count(columns: [PracticeToStudentGradeMetricSelectColumn!], distinct: Boolean): Int!
  max: PracticeToStudentGradeMetricMaxFields
  min: PracticeToStudentGradeMetricMinFields
  stddev: PracticeToStudentGradeMetricStddevFields
  stddevPop: PracticeToStudentGradeMetricStddevPopFields
  stddevSamp: PracticeToStudentGradeMetricStddevSampFields
  sum: PracticeToStudentGradeMetricSumFields
  varPop: PracticeToStudentGradeMetricVarPopFields
  varSamp: PracticeToStudentGradeMetricVarSampFields
  variance: PracticeToStudentGradeMetricVarianceFields
}

"""
order by aggregate values of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricAggregateOrderBy {
  avg: PracticeToStudentGradeMetricAvgOrderBy
  count: OrderBy
  max: PracticeToStudentGradeMetricMaxOrderBy
  min: PracticeToStudentGradeMetricMinOrderBy
  stddev: PracticeToStudentGradeMetricStddevOrderBy
  stddevPop: PracticeToStudentGradeMetricStddevPopOrderBy
  stddevSamp: PracticeToStudentGradeMetricStddevSampOrderBy
  sum: PracticeToStudentGradeMetricSumOrderBy
  varPop: PracticeToStudentGradeMetricVarPopOrderBy
  varSamp: PracticeToStudentGradeMetricVarSampOrderBy
  variance: PracticeToStudentGradeMetricVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input PracticeToStudentGradeMetricAppendInput {
  feedback: jsonb
}

"""
input type for inserting array relation for remote table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricArrRelInsertInput {
  data: [PracticeToStudentGradeMetricInsertInput!]!

  """upsert condition"""
  onConflict: PracticeToStudentGradeMetricOnConflict
}

"""aggregate avg on columns"""
type PracticeToStudentGradeMetricAvgFields {
  percentGrade: Float
}

"""
order by avg() on columns of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricAvgOrderBy {
  percentGrade: OrderBy
}

"""
Boolean expression to filter rows from the table "practice_to_student_grade_metric". All fields are combined with a logical 'AND'.
"""
input PracticeToStudentGradeMetricBoolExp {
  _and: [PracticeToStudentGradeMetricBoolExp!]
  _not: PracticeToStudentGradeMetricBoolExp
  _or: [PracticeToStudentGradeMetricBoolExp!]
  createdAt: TimestamptzComparisonExp
  feedback: JsonbComparisonExp
  id: UuidComparisonExp
  percentGrade: NumericComparisonExp
  practiceToStudentYield: PracticeToStudentYieldBoolExp
  practiceToStudentYieldId: UuidComparisonExp
  practiceYieldGradeMetric: PracticeYieldGradeMetricBoolExp
  practiceYieldGradeMetricId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "practice_to_student_grade_metric"
"""
enum PracticeToStudentGradeMetricConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  practice_to_student_grade_metric_pkey

  """
  unique or primary key constraint on columns "practice_to_student_yield_id", "practice_yield_grade_metric_id"
  """
  practice_to_student_grade_metric_practice_yield_grade_metric_id
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input PracticeToStudentGradeMetricDeleteAtPathInput {
  feedback: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input PracticeToStudentGradeMetricDeleteElemInput {
  feedback: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input PracticeToStudentGradeMetricDeleteKeyInput {
  feedback: String
}

"""
input type for incrementing numeric columns in table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricIncInput {
  percentGrade: numeric
}

"""
input type for inserting data into table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricInsertInput {
  createdAt: timestamptz
  feedback: jsonb
  id: uuid
  percentGrade: numeric
  practiceToStudentYield: PracticeToStudentYieldObjRelInsertInput
  practiceToStudentYieldId: uuid
  practiceYieldGradeMetric: PracticeYieldGradeMetricObjRelInsertInput
  practiceYieldGradeMetricId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PracticeToStudentGradeMetricMaxFields {
  createdAt: timestamptz
  id: uuid
  percentGrade: numeric
  practiceToStudentYieldId: uuid
  practiceYieldGradeMetricId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  percentGrade: OrderBy
  practiceToStudentYieldId: OrderBy
  practiceYieldGradeMetricId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PracticeToStudentGradeMetricMinFields {
  createdAt: timestamptz
  id: uuid
  percentGrade: numeric
  practiceToStudentYieldId: uuid
  practiceYieldGradeMetricId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  percentGrade: OrderBy
  practiceToStudentYieldId: OrderBy
  practiceYieldGradeMetricId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "practice_to_student_grade_metric"
"""
type PracticeToStudentGradeMetricMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeToStudentGradeMetric!]!
}

"""
on_conflict condition type for table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricOnConflict {
  constraint: PracticeToStudentGradeMetricConstraint!
  updateColumns: [PracticeToStudentGradeMetricUpdateColumn!]! = []
  where: PracticeToStudentGradeMetricBoolExp
}

"""
Ordering options when selecting data from "practice_to_student_grade_metric".
"""
input PracticeToStudentGradeMetricOrderBy {
  createdAt: OrderBy
  feedback: OrderBy
  id: OrderBy
  percentGrade: OrderBy
  practiceToStudentYield: PracticeToStudentYieldOrderBy
  practiceToStudentYieldId: OrderBy
  practiceYieldGradeMetric: PracticeYieldGradeMetricOrderBy
  practiceYieldGradeMetricId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: practice_to_student_grade_metric"""
input PracticeToStudentGradeMetricPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input PracticeToStudentGradeMetricPrependInput {
  feedback: jsonb
}

"""
select columns of table "practice_to_student_grade_metric"
"""
enum PracticeToStudentGradeMetricSelectColumn {
  """column name"""
  createdAt

  """column name"""
  feedback

  """column name"""
  id

  """column name"""
  percentGrade

  """column name"""
  practiceToStudentYieldId

  """column name"""
  practiceYieldGradeMetricId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricSetInput {
  createdAt: timestamptz
  feedback: jsonb
  id: uuid
  percentGrade: numeric
  practiceToStudentYieldId: uuid
  practiceYieldGradeMetricId: uuid
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type PracticeToStudentGradeMetricStddevFields {
  percentGrade: Float
}

"""
order by stddev() on columns of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricStddevOrderBy {
  percentGrade: OrderBy
}

"""aggregate stddevPop on columns"""
type PracticeToStudentGradeMetricStddevPopFields {
  percentGrade: Float
}

"""
order by stddevPop() on columns of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricStddevPopOrderBy {
  percentGrade: OrderBy
}

"""aggregate stddevSamp on columns"""
type PracticeToStudentGradeMetricStddevSampFields {
  percentGrade: Float
}

"""
order by stddevSamp() on columns of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricStddevSampOrderBy {
  percentGrade: OrderBy
}

"""
Streaming cursor of the table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeToStudentGradeMetricStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeToStudentGradeMetricStreamCursorValueInput {
  createdAt: timestamptz
  feedback: jsonb
  id: uuid
  percentGrade: numeric
  practiceToStudentYieldId: uuid
  practiceYieldGradeMetricId: uuid
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type PracticeToStudentGradeMetricSumFields {
  percentGrade: numeric
}

"""
order by sum() on columns of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricSumOrderBy {
  percentGrade: OrderBy
}

"""
update columns of table "practice_to_student_grade_metric"
"""
enum PracticeToStudentGradeMetricUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  feedback

  """column name"""
  id

  """column name"""
  percentGrade

  """column name"""
  practiceToStudentYieldId

  """column name"""
  practiceYieldGradeMetricId

  """column name"""
  updatedAt
}

input PracticeToStudentGradeMetricUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: PracticeToStudentGradeMetricAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: PracticeToStudentGradeMetricDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: PracticeToStudentGradeMetricDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: PracticeToStudentGradeMetricDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: PracticeToStudentGradeMetricIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: PracticeToStudentGradeMetricPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: PracticeToStudentGradeMetricSetInput

  """filter the rows which have to be updated"""
  where: PracticeToStudentGradeMetricBoolExp!
}

"""aggregate varPop on columns"""
type PracticeToStudentGradeMetricVarPopFields {
  percentGrade: Float
}

"""
order by varPop() on columns of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricVarPopOrderBy {
  percentGrade: OrderBy
}

"""aggregate varSamp on columns"""
type PracticeToStudentGradeMetricVarSampFields {
  percentGrade: Float
}

"""
order by varSamp() on columns of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricVarSampOrderBy {
  percentGrade: OrderBy
}

"""aggregate variance on columns"""
type PracticeToStudentGradeMetricVarianceFields {
  percentGrade: Float
}

"""
order by variance() on columns of table "practice_to_student_grade_metric"
"""
input PracticeToStudentGradeMetricVarianceOrderBy {
  percentGrade: OrderBy
}

"""aggregate min on columns"""
type PracticeToStudentGradeMinFields {
  grade: float8
  practiceToStudentId: uuid
}

"""
response of any mutation on the table "practice_to_student_grade"
"""
type PracticeToStudentGradeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeToStudentGrade!]!
}

"""Ordering options when selecting data from "practice_to_student_grade"."""
input PracticeToStudentGradeOrderBy {
  grade: OrderBy
  gradeDetail: OrderBy
  practiceToStudent: PracticeToStudentOrderBy
  practiceToStudentId: OrderBy
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input PracticeToStudentGradePrependInput {
  gradeDetail: jsonb
}

"""
select columns of table "practice_to_student_grade"
"""
enum PracticeToStudentGradeSelectColumn {
  """column name"""
  grade

  """column name"""
  gradeDetail

  """column name"""
  practiceToStudentId
}

"""
input type for updating data in table "practice_to_student_grade"
"""
input PracticeToStudentGradeSetInput {
  grade: float8
  gradeDetail: jsonb
  practiceToStudentId: uuid
}

"""aggregate stddev on columns"""
type PracticeToStudentGradeStddevFields {
  grade: Float
}

"""aggregate stddevPop on columns"""
type PracticeToStudentGradeStddevPopFields {
  grade: Float
}

"""aggregate stddevSamp on columns"""
type PracticeToStudentGradeStddevSampFields {
  grade: Float
}

"""
Streaming cursor of the table "practice_to_student_grade"
"""
input PracticeToStudentGradeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeToStudentGradeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeToStudentGradeStreamCursorValueInput {
  grade: float8
  gradeDetail: jsonb
  practiceToStudentId: uuid
}

"""aggregate sum on columns"""
type PracticeToStudentGradeSumFields {
  grade: float8
}

input PracticeToStudentGradeUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: PracticeToStudentGradeAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: PracticeToStudentGradeDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: PracticeToStudentGradeDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: PracticeToStudentGradeDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: PracticeToStudentGradeIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: PracticeToStudentGradePrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: PracticeToStudentGradeSetInput

  """filter the rows which have to be updated"""
  where: PracticeToStudentGradeBoolExp!
}

"""aggregate varPop on columns"""
type PracticeToStudentGradeVarPopFields {
  grade: Float
}

"""aggregate varSamp on columns"""
type PracticeToStudentGradeVarSampFields {
  grade: Float
}

"""aggregate variance on columns"""
type PracticeToStudentGradeVarianceFields {
  grade: Float
}

"""
input type for incrementing numeric columns in table "practice_to_student"
"""
input PracticeToStudentIncInput {
  grade: float8
}

"""
input type for inserting data into table "practice_to_student"
"""
input PracticeToStudentInsertInput {
  coursePracticeId: uuid
  createdAt: timestamptz
  feedback: jsonb
  grade: float8
  gradeDetail: jsonb
  graded: Boolean
  id: uuid
  practiceToCourse: PracticeToCourseObjRelInsertInput
  practiceToStudentYields: PracticeToStudentYieldArrRelInsertInput
  student: StudentObjRelInsertInput
  studentId: uuid
  submited: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PracticeToStudentMaxFields {
  coursePracticeId: uuid
  createdAt: timestamptz
  grade: float8
  id: uuid
  studentId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "practice_to_student"
"""
input PracticeToStudentMaxOrderBy {
  coursePracticeId: OrderBy
  createdAt: OrderBy
  grade: OrderBy
  id: OrderBy
  studentId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PracticeToStudentMinFields {
  coursePracticeId: uuid
  createdAt: timestamptz
  grade: float8
  id: uuid
  studentId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "practice_to_student"
"""
input PracticeToStudentMinOrderBy {
  coursePracticeId: OrderBy
  createdAt: OrderBy
  grade: OrderBy
  id: OrderBy
  studentId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "practice_to_student"
"""
type PracticeToStudentMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeToStudent!]!
}

"""
input type for inserting object relation for remote table "practice_to_student"
"""
input PracticeToStudentObjRelInsertInput {
  data: PracticeToStudentInsertInput!

  """upsert condition"""
  onConflict: PracticeToStudentOnConflict
}

"""
on_conflict condition type for table "practice_to_student"
"""
input PracticeToStudentOnConflict {
  constraint: PracticeToStudentConstraint!
  updateColumns: [PracticeToStudentUpdateColumn!]! = []
  where: PracticeToStudentBoolExp
}

"""Ordering options when selecting data from "practice_to_student"."""
input PracticeToStudentOrderBy {
  coursePracticeId: OrderBy
  createdAt: OrderBy
  feedback: OrderBy
  grade: OrderBy
  gradeDetail: OrderBy
  graded: OrderBy
  id: OrderBy
  practiceToCourse: PracticeToCourseOrderBy
  practiceToStudentYieldsAggregate: PracticeToStudentYieldAggregateOrderBy
  student: StudentOrderBy
  studentId: OrderBy
  submited: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: practice_to_student"""
input PracticeToStudentPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input PracticeToStudentPrependInput {
  feedback: jsonb
  gradeDetail: jsonb
}

"""
select columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumn {
  """column name"""
  coursePracticeId

  """column name"""
  createdAt

  """column name"""
  feedback

  """column name"""
  grade

  """column name"""
  gradeDetail

  """column name"""
  graded

  """column name"""
  id

  """column name"""
  studentId

  """column name"""
  submited

  """column name"""
  updatedAt
}

"""
select "practiceToStudentAggregateBoolExpAvgArgumentsColumns" columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpAvgArgumentsColumns {
  """column name"""
  grade
}

"""
select "practiceToStudentAggregateBoolExpBool_andArgumentsColumns" columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  graded

  """column name"""
  submited
}

"""
select "practiceToStudentAggregateBoolExpBool_orArgumentsColumns" columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  graded

  """column name"""
  submited
}

"""
select "practiceToStudentAggregateBoolExpCorrArgumentsColumns" columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpCorrArgumentsColumns {
  """column name"""
  grade
}

"""
select "practiceToStudentAggregateBoolExpCovar_sampArgumentsColumns" columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpCovar_sampArgumentsColumns {
  """column name"""
  grade
}

"""
select "practiceToStudentAggregateBoolExpMaxArgumentsColumns" columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpMaxArgumentsColumns {
  """column name"""
  grade
}

"""
select "practiceToStudentAggregateBoolExpMinArgumentsColumns" columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpMinArgumentsColumns {
  """column name"""
  grade
}

"""
select "practiceToStudentAggregateBoolExpStddev_sampArgumentsColumns" columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpStddev_sampArgumentsColumns {
  """column name"""
  grade
}

"""
select "practiceToStudentAggregateBoolExpSumArgumentsColumns" columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpSumArgumentsColumns {
  """column name"""
  grade
}

"""
select "practiceToStudentAggregateBoolExpVar_sampArgumentsColumns" columns of table "practice_to_student"
"""
enum PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpVar_sampArgumentsColumns {
  """column name"""
  grade
}

"""
input type for updating data in table "practice_to_student"
"""
input PracticeToStudentSetInput {
  coursePracticeId: uuid
  createdAt: timestamptz
  feedback: jsonb
  grade: float8
  gradeDetail: jsonb
  graded: Boolean
  id: uuid
  studentId: uuid
  submited: Boolean
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type PracticeToStudentStddevFields {
  grade: Float
}

"""
order by stddev() on columns of table "practice_to_student"
"""
input PracticeToStudentStddevOrderBy {
  grade: OrderBy
}

"""aggregate stddevPop on columns"""
type PracticeToStudentStddevPopFields {
  grade: Float
}

"""
order by stddevPop() on columns of table "practice_to_student"
"""
input PracticeToStudentStddevPopOrderBy {
  grade: OrderBy
}

"""aggregate stddevSamp on columns"""
type PracticeToStudentStddevSampFields {
  grade: Float
}

"""
order by stddevSamp() on columns of table "practice_to_student"
"""
input PracticeToStudentStddevSampOrderBy {
  grade: OrderBy
}

"""
Streaming cursor of the table "practice_to_student"
"""
input PracticeToStudentStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeToStudentStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeToStudentStreamCursorValueInput {
  coursePracticeId: uuid
  createdAt: timestamptz
  feedback: jsonb
  grade: float8
  gradeDetail: jsonb
  graded: Boolean
  id: uuid
  studentId: uuid
  submited: Boolean
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type PracticeToStudentSumFields {
  grade: float8
}

"""
order by sum() on columns of table "practice_to_student"
"""
input PracticeToStudentSumOrderBy {
  grade: OrderBy
}

"""
update columns of table "practice_to_student"
"""
enum PracticeToStudentUpdateColumn {
  """column name"""
  coursePracticeId

  """column name"""
  createdAt

  """column name"""
  feedback

  """column name"""
  grade

  """column name"""
  gradeDetail

  """column name"""
  graded

  """column name"""
  id

  """column name"""
  studentId

  """column name"""
  submited

  """column name"""
  updatedAt
}

input PracticeToStudentUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: PracticeToStudentAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: PracticeToStudentDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: PracticeToStudentDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: PracticeToStudentDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: PracticeToStudentIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: PracticeToStudentPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: PracticeToStudentSetInput

  """filter the rows which have to be updated"""
  where: PracticeToStudentBoolExp!
}

"""aggregate varPop on columns"""
type PracticeToStudentVarPopFields {
  grade: Float
}

"""
order by varPop() on columns of table "practice_to_student"
"""
input PracticeToStudentVarPopOrderBy {
  grade: OrderBy
}

"""aggregate varSamp on columns"""
type PracticeToStudentVarSampFields {
  grade: Float
}

"""
order by varSamp() on columns of table "practice_to_student"
"""
input PracticeToStudentVarSampOrderBy {
  grade: OrderBy
}

"""aggregate variance on columns"""
type PracticeToStudentVarianceFields {
  grade: Float
}

"""
order by variance() on columns of table "practice_to_student"
"""
input PracticeToStudentVarianceOrderBy {
  grade: OrderBy
}

"""
columns and relationships of "practice_to_student_yield"
"""
type PracticeToStudentYield {
  createdAt: timestamptz!
  giteaOrgAndRepo: String
  id: uuid!

  """An object relationship"""
  practiceToStudent: PracticeToStudent!

  """An array relationship"""
  practiceToStudentGradeMetrics(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeMetricBoolExp
  ): [PracticeToStudentGradeMetric!]!

  """An aggregate relationship"""
  practiceToStudentGradeMetricsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeMetricBoolExp
  ): PracticeToStudentGradeMetricAggregate!
  practiceToStudentId: uuid!

  """An object relationship"""
  practiceYield: PracticeYield!
  practiceYieldId: uuid!
  submited: Boolean!
  updatedAt: timestamptz!
  value: String!
}

"""
aggregated selection of "practice_to_student_yield"
"""
type PracticeToStudentYieldAggregate {
  aggregate: PracticeToStudentYieldAggregateFields
  nodes: [PracticeToStudentYield!]!
}

input PracticeToStudentYieldAggregateBoolExp {
  bool_and: practiceToStudentYieldAggregateBoolExpBool_and
  bool_or: practiceToStudentYieldAggregateBoolExpBool_or
  count: practiceToStudentYieldAggregateBoolExpCount
}

"""
aggregate fields of "practice_to_student_yield"
"""
type PracticeToStudentYieldAggregateFields {
  count(columns: [PracticeToStudentYieldSelectColumn!], distinct: Boolean): Int!
  max: PracticeToStudentYieldMaxFields
  min: PracticeToStudentYieldMinFields
}

"""
order by aggregate values of table "practice_to_student_yield"
"""
input PracticeToStudentYieldAggregateOrderBy {
  count: OrderBy
  max: PracticeToStudentYieldMaxOrderBy
  min: PracticeToStudentYieldMinOrderBy
}

"""
input type for inserting array relation for remote table "practice_to_student_yield"
"""
input PracticeToStudentYieldArrRelInsertInput {
  data: [PracticeToStudentYieldInsertInput!]!

  """upsert condition"""
  onConflict: PracticeToStudentYieldOnConflict
}

"""
Boolean expression to filter rows from the table "practice_to_student_yield". All fields are combined with a logical 'AND'.
"""
input PracticeToStudentYieldBoolExp {
  _and: [PracticeToStudentYieldBoolExp!]
  _not: PracticeToStudentYieldBoolExp
  _or: [PracticeToStudentYieldBoolExp!]
  createdAt: TimestamptzComparisonExp
  giteaOrgAndRepo: StringComparisonExp
  id: UuidComparisonExp
  practiceToStudent: PracticeToStudentBoolExp
  practiceToStudentGradeMetrics: PracticeToStudentGradeMetricBoolExp
  practiceToStudentGradeMetricsAggregate: PracticeToStudentGradeMetricAggregateBoolExp
  practiceToStudentId: UuidComparisonExp
  practiceYield: PracticeYieldBoolExp
  practiceYieldId: UuidComparisonExp
  submited: BooleanComparisonExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "practice_to_student_yield"
"""
enum PracticeToStudentYieldConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  student_practice_yield_pkey

  """
  unique or primary key constraint on columns "practice_yield_id", "practice_to_student_id"
  """
  student_practice_yield_practice_yield_id_practice_to_studen_key
}

"""
input type for inserting data into table "practice_to_student_yield"
"""
input PracticeToStudentYieldInsertInput {
  createdAt: timestamptz
  giteaOrgAndRepo: String
  id: uuid
  practiceToStudent: PracticeToStudentObjRelInsertInput
  practiceToStudentGradeMetrics: PracticeToStudentGradeMetricArrRelInsertInput
  practiceToStudentId: uuid
  practiceYield: PracticeYieldObjRelInsertInput
  practiceYieldId: uuid
  submited: Boolean
  updatedAt: timestamptz
  value: String
}

"""aggregate max on columns"""
type PracticeToStudentYieldMaxFields {
  createdAt: timestamptz
  giteaOrgAndRepo: String
  id: uuid
  practiceToStudentId: uuid
  practiceYieldId: uuid
  updatedAt: timestamptz
  value: String
}

"""
order by max() on columns of table "practice_to_student_yield"
"""
input PracticeToStudentYieldMaxOrderBy {
  createdAt: OrderBy
  giteaOrgAndRepo: OrderBy
  id: OrderBy
  practiceToStudentId: OrderBy
  practiceYieldId: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""aggregate min on columns"""
type PracticeToStudentYieldMinFields {
  createdAt: timestamptz
  giteaOrgAndRepo: String
  id: uuid
  practiceToStudentId: uuid
  practiceYieldId: uuid
  updatedAt: timestamptz
  value: String
}

"""
order by min() on columns of table "practice_to_student_yield"
"""
input PracticeToStudentYieldMinOrderBy {
  createdAt: OrderBy
  giteaOrgAndRepo: OrderBy
  id: OrderBy
  practiceToStudentId: OrderBy
  practiceYieldId: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""
response of any mutation on the table "practice_to_student_yield"
"""
type PracticeToStudentYieldMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeToStudentYield!]!
}

"""
input type for inserting object relation for remote table "practice_to_student_yield"
"""
input PracticeToStudentYieldObjRelInsertInput {
  data: PracticeToStudentYieldInsertInput!

  """upsert condition"""
  onConflict: PracticeToStudentYieldOnConflict
}

"""
on_conflict condition type for table "practice_to_student_yield"
"""
input PracticeToStudentYieldOnConflict {
  constraint: PracticeToStudentYieldConstraint!
  updateColumns: [PracticeToStudentYieldUpdateColumn!]! = []
  where: PracticeToStudentYieldBoolExp
}

"""Ordering options when selecting data from "practice_to_student_yield"."""
input PracticeToStudentYieldOrderBy {
  createdAt: OrderBy
  giteaOrgAndRepo: OrderBy
  id: OrderBy
  practiceToStudent: PracticeToStudentOrderBy
  practiceToStudentGradeMetricsAggregate: PracticeToStudentGradeMetricAggregateOrderBy
  practiceToStudentId: OrderBy
  practiceYield: PracticeYieldOrderBy
  practiceYieldId: OrderBy
  submited: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: practice_to_student_yield"""
input PracticeToStudentYieldPkColumnsInput {
  id: uuid!
}

"""
select columns of table "practice_to_student_yield"
"""
enum PracticeToStudentYieldSelectColumn {
  """column name"""
  createdAt

  """column name"""
  giteaOrgAndRepo

  """column name"""
  id

  """column name"""
  practiceToStudentId

  """column name"""
  practiceYieldId

  """column name"""
  submited

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
select "practiceToStudentYieldAggregateBoolExpBool_andArgumentsColumns" columns of table "practice_to_student_yield"
"""
enum PracticeToStudentYieldSelectColumnPracticeToStudentYieldAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  submited
}

"""
select "practiceToStudentYieldAggregateBoolExpBool_orArgumentsColumns" columns of table "practice_to_student_yield"
"""
enum PracticeToStudentYieldSelectColumnPracticeToStudentYieldAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  submited
}

"""
input type for updating data in table "practice_to_student_yield"
"""
input PracticeToStudentYieldSetInput {
  createdAt: timestamptz
  giteaOrgAndRepo: String
  id: uuid
  practiceToStudentId: uuid
  practiceYieldId: uuid
  submited: Boolean
  updatedAt: timestamptz
  value: String
}

"""
Streaming cursor of the table "practice_to_student_yield"
"""
input PracticeToStudentYieldStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeToStudentYieldStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeToStudentYieldStreamCursorValueInput {
  createdAt: timestamptz
  giteaOrgAndRepo: String
  id: uuid
  practiceToStudentId: uuid
  practiceYieldId: uuid
  submited: Boolean
  updatedAt: timestamptz
  value: String
}

"""
update columns of table "practice_to_student_yield"
"""
enum PracticeToStudentYieldUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  giteaOrgAndRepo

  """column name"""
  id

  """column name"""
  practiceToStudentId

  """column name"""
  practiceYieldId

  """column name"""
  submited

  """column name"""
  updatedAt

  """column name"""
  value
}

input PracticeToStudentYieldUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PracticeToStudentYieldSetInput

  """filter the rows which have to be updated"""
  where: PracticeToStudentYieldBoolExp!
}

"""
update columns of table "practice"
"""
enum PracticeUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  title

  """column name"""
  updatedAt
}

input PracticeUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PracticeSetInput

  """filter the rows which have to be updated"""
  where: PracticeBoolExp!
}

"""
columns and relationships of "practice_yield"
"""
type PracticeYield {
  createdAt: timestamptz!
  description: String
  id: uuid!
  meta(
    """JSON select path"""
    path: String
  ): jsonb
  method: String!
  name: String!

  """An object relationship"""
  practice: Practice!
  practiceId: uuid!

  """An array relationship"""
  practiceToStudentYields(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentYieldBoolExp
  ): [PracticeToStudentYield!]!

  """An aggregate relationship"""
  practiceToStudentYieldsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentYieldBoolExp
  ): PracticeToStudentYieldAggregate!

  """An array relationship"""
  practiceYieldExpectedOutputs(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputBoolExp
  ): [PracticeYieldExpectedOutput!]!

  """An aggregate relationship"""
  practiceYieldExpectedOutputsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputBoolExp
  ): PracticeYieldExpectedOutputAggregate!

  """An object relationship"""
  practiceYieldType: PracticeYieldType!
  updatedAt: timestamptz!
}

"""
aggregated selection of "practice_yield"
"""
type PracticeYieldAggregate {
  aggregate: PracticeYieldAggregateFields
  nodes: [PracticeYield!]!
}

input PracticeYieldAggregateBoolExp {
  count: practiceYieldAggregateBoolExpCount
}

"""
aggregate fields of "practice_yield"
"""
type PracticeYieldAggregateFields {
  count(columns: [PracticeYieldSelectColumn!], distinct: Boolean): Int!
  max: PracticeYieldMaxFields
  min: PracticeYieldMinFields
}

"""
order by aggregate values of table "practice_yield"
"""
input PracticeYieldAggregateOrderBy {
  count: OrderBy
  max: PracticeYieldMaxOrderBy
  min: PracticeYieldMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input PracticeYieldAppendInput {
  meta: jsonb
}

"""
input type for inserting array relation for remote table "practice_yield"
"""
input PracticeYieldArrRelInsertInput {
  data: [PracticeYieldInsertInput!]!

  """upsert condition"""
  onConflict: PracticeYieldOnConflict
}

"""
Boolean expression to filter rows from the table "practice_yield". All fields are combined with a logical 'AND'.
"""
input PracticeYieldBoolExp {
  _and: [PracticeYieldBoolExp!]
  _not: PracticeYieldBoolExp
  _or: [PracticeYieldBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  meta: JsonbComparisonExp
  method: StringComparisonExp
  name: StringComparisonExp
  practice: PracticeBoolExp
  practiceId: UuidComparisonExp
  practiceToStudentYields: PracticeToStudentYieldBoolExp
  practiceToStudentYieldsAggregate: PracticeToStudentYieldAggregateBoolExp
  practiceYieldExpectedOutputs: PracticeYieldExpectedOutputBoolExp
  practiceYieldExpectedOutputsAggregate: PracticeYieldExpectedOutputAggregateBoolExp
  practiceYieldType: PracticeYieldTypeBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "practice_yield"
"""
enum PracticeYieldConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  practice_yield_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input PracticeYieldDeleteAtPathInput {
  meta: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input PracticeYieldDeleteElemInput {
  meta: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input PracticeYieldDeleteKeyInput {
  meta: String
}

"""
columns and relationships of "practice_yield_expected_output"
"""
type PracticeYieldExpectedOutput {
  codeLang: String
  createdAt: timestamptz!
  expected: String
  gitPath: String
  id: uuid!
  method: PracticeYieldExpectedOutputTypesEnum!

  """An object relationship"""
  practiceYield: PracticeYield!

  """An object relationship"""
  practiceYieldExpectedOutputType: PracticeYieldExpectedOutputTypes!

  """An array relationship"""
  practiceYieldGradeMetrics(
    """distinct select on columns"""
    distinctOn: [PracticeYieldGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldGradeMetricBoolExp
  ): [PracticeYieldGradeMetric!]!

  """An aggregate relationship"""
  practiceYieldGradeMetricsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldGradeMetricBoolExp
  ): PracticeYieldGradeMetricAggregate!
  practiceYieldId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "practice_yield_expected_output"
"""
type PracticeYieldExpectedOutputAggregate {
  aggregate: PracticeYieldExpectedOutputAggregateFields
  nodes: [PracticeYieldExpectedOutput!]!
}

input PracticeYieldExpectedOutputAggregateBoolExp {
  count: practiceYieldExpectedOutputAggregateBoolExpCount
}

"""
aggregate fields of "practice_yield_expected_output"
"""
type PracticeYieldExpectedOutputAggregateFields {
  count(columns: [PracticeYieldExpectedOutputSelectColumn!], distinct: Boolean): Int!
  max: PracticeYieldExpectedOutputMaxFields
  min: PracticeYieldExpectedOutputMinFields
}

"""
order by aggregate values of table "practice_yield_expected_output"
"""
input PracticeYieldExpectedOutputAggregateOrderBy {
  count: OrderBy
  max: PracticeYieldExpectedOutputMaxOrderBy
  min: PracticeYieldExpectedOutputMinOrderBy
}

"""
input type for inserting array relation for remote table "practice_yield_expected_output"
"""
input PracticeYieldExpectedOutputArrRelInsertInput {
  data: [PracticeYieldExpectedOutputInsertInput!]!

  """upsert condition"""
  onConflict: PracticeYieldExpectedOutputOnConflict
}

"""
Boolean expression to filter rows from the table "practice_yield_expected_output". All fields are combined with a logical 'AND'.
"""
input PracticeYieldExpectedOutputBoolExp {
  _and: [PracticeYieldExpectedOutputBoolExp!]
  _not: PracticeYieldExpectedOutputBoolExp
  _or: [PracticeYieldExpectedOutputBoolExp!]
  codeLang: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  expected: StringComparisonExp
  gitPath: StringComparisonExp
  id: UuidComparisonExp
  method: PracticeYieldExpectedOutputTypesEnumComparisonExp
  practiceYield: PracticeYieldBoolExp
  practiceYieldExpectedOutputType: PracticeYieldExpectedOutputTypesBoolExp
  practiceYieldGradeMetrics: PracticeYieldGradeMetricBoolExp
  practiceYieldGradeMetricsAggregate: PracticeYieldGradeMetricAggregateBoolExp
  practiceYieldId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "practice_yield_expected_output"
"""
enum PracticeYieldExpectedOutputConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  practice_yield_expected_output_pkey

  """
  unique or primary key constraint on columns "practice_yield_id", "git_path", "method"
  """
  practice_yield_expected_output_practice_yield_id_git_path_metho
}

"""
input type for inserting data into table "practice_yield_expected_output"
"""
input PracticeYieldExpectedOutputInsertInput {
  codeLang: String
  createdAt: timestamptz
  expected: String
  gitPath: String
  id: uuid
  method: PracticeYieldExpectedOutputTypesEnum
  practiceYield: PracticeYieldObjRelInsertInput
  practiceYieldExpectedOutputType: PracticeYieldExpectedOutputTypesObjRelInsertInput
  practiceYieldGradeMetrics: PracticeYieldGradeMetricArrRelInsertInput
  practiceYieldId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PracticeYieldExpectedOutputMaxFields {
  codeLang: String
  createdAt: timestamptz
  expected: String
  gitPath: String
  id: uuid
  practiceYieldId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "practice_yield_expected_output"
"""
input PracticeYieldExpectedOutputMaxOrderBy {
  codeLang: OrderBy
  createdAt: OrderBy
  expected: OrderBy
  gitPath: OrderBy
  id: OrderBy
  practiceYieldId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PracticeYieldExpectedOutputMinFields {
  codeLang: String
  createdAt: timestamptz
  expected: String
  gitPath: String
  id: uuid
  practiceYieldId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "practice_yield_expected_output"
"""
input PracticeYieldExpectedOutputMinOrderBy {
  codeLang: OrderBy
  createdAt: OrderBy
  expected: OrderBy
  gitPath: OrderBy
  id: OrderBy
  practiceYieldId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "practice_yield_expected_output"
"""
type PracticeYieldExpectedOutputMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeYieldExpectedOutput!]!
}

"""
input type for inserting object relation for remote table "practice_yield_expected_output"
"""
input PracticeYieldExpectedOutputObjRelInsertInput {
  data: PracticeYieldExpectedOutputInsertInput!

  """upsert condition"""
  onConflict: PracticeYieldExpectedOutputOnConflict
}

"""
on_conflict condition type for table "practice_yield_expected_output"
"""
input PracticeYieldExpectedOutputOnConflict {
  constraint: PracticeYieldExpectedOutputConstraint!
  updateColumns: [PracticeYieldExpectedOutputUpdateColumn!]! = []
  where: PracticeYieldExpectedOutputBoolExp
}

"""
Ordering options when selecting data from "practice_yield_expected_output".
"""
input PracticeYieldExpectedOutputOrderBy {
  codeLang: OrderBy
  createdAt: OrderBy
  expected: OrderBy
  gitPath: OrderBy
  id: OrderBy
  method: OrderBy
  practiceYield: PracticeYieldOrderBy
  practiceYieldExpectedOutputType: PracticeYieldExpectedOutputTypesOrderBy
  practiceYieldGradeMetricsAggregate: PracticeYieldGradeMetricAggregateOrderBy
  practiceYieldId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: practice_yield_expected_output"""
input PracticeYieldExpectedOutputPkColumnsInput {
  id: uuid!
}

"""
select columns of table "practice_yield_expected_output"
"""
enum PracticeYieldExpectedOutputSelectColumn {
  """column name"""
  codeLang

  """column name"""
  createdAt

  """column name"""
  expected

  """column name"""
  gitPath

  """column name"""
  id

  """column name"""
  method

  """column name"""
  practiceYieldId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "practice_yield_expected_output"
"""
input PracticeYieldExpectedOutputSetInput {
  codeLang: String
  createdAt: timestamptz
  expected: String
  gitPath: String
  id: uuid
  method: PracticeYieldExpectedOutputTypesEnum
  practiceYieldId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "practice_yield_expected_output"
"""
input PracticeYieldExpectedOutputStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeYieldExpectedOutputStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeYieldExpectedOutputStreamCursorValueInput {
  codeLang: String
  createdAt: timestamptz
  expected: String
  gitPath: String
  id: uuid
  method: PracticeYieldExpectedOutputTypesEnum
  practiceYieldId: uuid
  updatedAt: timestamptz
}

"""
columns and relationships of "practice_yield_expected_output_types"
"""
type PracticeYieldExpectedOutputTypes {
  name: String!

  """An array relationship"""
  practiceYieldExpectedOutputs(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputBoolExp
  ): [PracticeYieldExpectedOutput!]!

  """An aggregate relationship"""
  practiceYieldExpectedOutputsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputBoolExp
  ): PracticeYieldExpectedOutputAggregate!
}

"""
aggregated selection of "practice_yield_expected_output_types"
"""
type PracticeYieldExpectedOutputTypesAggregate {
  aggregate: PracticeYieldExpectedOutputTypesAggregateFields
  nodes: [PracticeYieldExpectedOutputTypes!]!
}

"""
aggregate fields of "practice_yield_expected_output_types"
"""
type PracticeYieldExpectedOutputTypesAggregateFields {
  count(columns: [PracticeYieldExpectedOutputTypesSelectColumn!], distinct: Boolean): Int!
  max: PracticeYieldExpectedOutputTypesMaxFields
  min: PracticeYieldExpectedOutputTypesMinFields
}

"""
Boolean expression to filter rows from the table "practice_yield_expected_output_types". All fields are combined with a logical 'AND'.
"""
input PracticeYieldExpectedOutputTypesBoolExp {
  _and: [PracticeYieldExpectedOutputTypesBoolExp!]
  _not: PracticeYieldExpectedOutputTypesBoolExp
  _or: [PracticeYieldExpectedOutputTypesBoolExp!]
  name: StringComparisonExp
  practiceYieldExpectedOutputs: PracticeYieldExpectedOutputBoolExp
  practiceYieldExpectedOutputsAggregate: PracticeYieldExpectedOutputAggregateBoolExp
}

"""
unique or primary key constraints on table "practice_yield_expected_output_types"
"""
enum PracticeYieldExpectedOutputTypesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  practice_grade_metric_type_pkey
}

enum PracticeYieldExpectedOutputTypesEnum {
  COMPARE_CODE_FILE
  COMPARE_GIT_FILE
  LINK_OPEN
  MANUAL
  MANUAL_GIT_FILE_REVIEW
  SHOW_GIT_FILE
  SHOW_GIT_LOG
}

"""
Boolean expression to compare columns of type "PracticeYieldExpectedOutputTypesEnum". All fields are combined with logical 'AND'.
"""
input PracticeYieldExpectedOutputTypesEnumComparisonExp {
  _eq: PracticeYieldExpectedOutputTypesEnum
  _in: [PracticeYieldExpectedOutputTypesEnum!]
  _isNull: Boolean
  _neq: PracticeYieldExpectedOutputTypesEnum
  _nin: [PracticeYieldExpectedOutputTypesEnum!]
}

"""
input type for inserting data into table "practice_yield_expected_output_types"
"""
input PracticeYieldExpectedOutputTypesInsertInput {
  name: String
  practiceYieldExpectedOutputs: PracticeYieldExpectedOutputArrRelInsertInput
}

"""aggregate max on columns"""
type PracticeYieldExpectedOutputTypesMaxFields {
  name: String
}

"""aggregate min on columns"""
type PracticeYieldExpectedOutputTypesMinFields {
  name: String
}

"""
response of any mutation on the table "practice_yield_expected_output_types"
"""
type PracticeYieldExpectedOutputTypesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeYieldExpectedOutputTypes!]!
}

"""
input type for inserting object relation for remote table "practice_yield_expected_output_types"
"""
input PracticeYieldExpectedOutputTypesObjRelInsertInput {
  data: PracticeYieldExpectedOutputTypesInsertInput!

  """upsert condition"""
  onConflict: PracticeYieldExpectedOutputTypesOnConflict
}

"""
on_conflict condition type for table "practice_yield_expected_output_types"
"""
input PracticeYieldExpectedOutputTypesOnConflict {
  constraint: PracticeYieldExpectedOutputTypesConstraint!
  updateColumns: [PracticeYieldExpectedOutputTypesUpdateColumn!]! = []
  where: PracticeYieldExpectedOutputTypesBoolExp
}

"""
Ordering options when selecting data from "practice_yield_expected_output_types".
"""
input PracticeYieldExpectedOutputTypesOrderBy {
  name: OrderBy
  practiceYieldExpectedOutputsAggregate: PracticeYieldExpectedOutputAggregateOrderBy
}

"""
primary key columns input for table: practice_yield_expected_output_types
"""
input PracticeYieldExpectedOutputTypesPkColumnsInput {
  name: String!
}

"""
select columns of table "practice_yield_expected_output_types"
"""
enum PracticeYieldExpectedOutputTypesSelectColumn {
  """column name"""
  name
}

"""
input type for updating data in table "practice_yield_expected_output_types"
"""
input PracticeYieldExpectedOutputTypesSetInput {
  name: String
}

"""
Streaming cursor of the table "practice_yield_expected_output_types"
"""
input PracticeYieldExpectedOutputTypesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeYieldExpectedOutputTypesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeYieldExpectedOutputTypesStreamCursorValueInput {
  name: String
}

"""
update columns of table "practice_yield_expected_output_types"
"""
enum PracticeYieldExpectedOutputTypesUpdateColumn {
  """column name"""
  name
}

input PracticeYieldExpectedOutputTypesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PracticeYieldExpectedOutputTypesSetInput

  """filter the rows which have to be updated"""
  where: PracticeYieldExpectedOutputTypesBoolExp!
}

"""
update columns of table "practice_yield_expected_output"
"""
enum PracticeYieldExpectedOutputUpdateColumn {
  """column name"""
  codeLang

  """column name"""
  createdAt

  """column name"""
  expected

  """column name"""
  gitPath

  """column name"""
  id

  """column name"""
  method

  """column name"""
  practiceYieldId

  """column name"""
  updatedAt
}

input PracticeYieldExpectedOutputUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PracticeYieldExpectedOutputSetInput

  """filter the rows which have to be updated"""
  where: PracticeYieldExpectedOutputBoolExp!
}

"""
columns and relationships of "practice_yield_grade_metric"
"""
type PracticeYieldGradeMetric {
  createdAt: timestamptz!
  expectedYieldId: uuid!
  feedbacks(
    """JSON select path"""
    path: String
  ): jsonb!
  id: uuid!
  name: String!
  points: Int!

  """An array relationship"""
  practiceToStudentGradeMetrics(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeMetricBoolExp
  ): [PracticeToStudentGradeMetric!]!

  """An aggregate relationship"""
  practiceToStudentGradeMetricsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeMetricBoolExp
  ): PracticeToStudentGradeMetricAggregate!

  """An object relationship"""
  practiceYieldExpectedOutput: PracticeYieldExpectedOutput!
  updatedAt: timestamptz!
}

"""
aggregated selection of "practice_yield_grade_metric"
"""
type PracticeYieldGradeMetricAggregate {
  aggregate: PracticeYieldGradeMetricAggregateFields
  nodes: [PracticeYieldGradeMetric!]!
}

input PracticeYieldGradeMetricAggregateBoolExp {
  count: practiceYieldGradeMetricAggregateBoolExpCount
}

"""
aggregate fields of "practice_yield_grade_metric"
"""
type PracticeYieldGradeMetricAggregateFields {
  avg: PracticeYieldGradeMetricAvgFields
  count(columns: [PracticeYieldGradeMetricSelectColumn!], distinct: Boolean): Int!
  max: PracticeYieldGradeMetricMaxFields
  min: PracticeYieldGradeMetricMinFields
  stddev: PracticeYieldGradeMetricStddevFields
  stddevPop: PracticeYieldGradeMetricStddevPopFields
  stddevSamp: PracticeYieldGradeMetricStddevSampFields
  sum: PracticeYieldGradeMetricSumFields
  varPop: PracticeYieldGradeMetricVarPopFields
  varSamp: PracticeYieldGradeMetricVarSampFields
  variance: PracticeYieldGradeMetricVarianceFields
}

"""
order by aggregate values of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricAggregateOrderBy {
  avg: PracticeYieldGradeMetricAvgOrderBy
  count: OrderBy
  max: PracticeYieldGradeMetricMaxOrderBy
  min: PracticeYieldGradeMetricMinOrderBy
  stddev: PracticeYieldGradeMetricStddevOrderBy
  stddevPop: PracticeYieldGradeMetricStddevPopOrderBy
  stddevSamp: PracticeYieldGradeMetricStddevSampOrderBy
  sum: PracticeYieldGradeMetricSumOrderBy
  varPop: PracticeYieldGradeMetricVarPopOrderBy
  varSamp: PracticeYieldGradeMetricVarSampOrderBy
  variance: PracticeYieldGradeMetricVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input PracticeYieldGradeMetricAppendInput {
  feedbacks: jsonb
}

"""
input type for inserting array relation for remote table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricArrRelInsertInput {
  data: [PracticeYieldGradeMetricInsertInput!]!

  """upsert condition"""
  onConflict: PracticeYieldGradeMetricOnConflict
}

"""aggregate avg on columns"""
type PracticeYieldGradeMetricAvgFields {
  points: Float
}

"""
order by avg() on columns of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricAvgOrderBy {
  points: OrderBy
}

"""
Boolean expression to filter rows from the table "practice_yield_grade_metric". All fields are combined with a logical 'AND'.
"""
input PracticeYieldGradeMetricBoolExp {
  _and: [PracticeYieldGradeMetricBoolExp!]
  _not: PracticeYieldGradeMetricBoolExp
  _or: [PracticeYieldGradeMetricBoolExp!]
  createdAt: TimestamptzComparisonExp
  expectedYieldId: UuidComparisonExp
  feedbacks: JsonbComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  points: IntComparisonExp
  practiceToStudentGradeMetrics: PracticeToStudentGradeMetricBoolExp
  practiceToStudentGradeMetricsAggregate: PracticeToStudentGradeMetricAggregateBoolExp
  practiceYieldExpectedOutput: PracticeYieldExpectedOutputBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "practice_yield_grade_metric"
"""
enum PracticeYieldGradeMetricConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  practice_grade_metric_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input PracticeYieldGradeMetricDeleteAtPathInput {
  feedbacks: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input PracticeYieldGradeMetricDeleteElemInput {
  feedbacks: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input PracticeYieldGradeMetricDeleteKeyInput {
  feedbacks: String
}

"""
input type for incrementing numeric columns in table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricIncInput {
  points: Int
}

"""
input type for inserting data into table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricInsertInput {
  createdAt: timestamptz
  expectedYieldId: uuid
  feedbacks: jsonb
  id: uuid
  name: String
  points: Int
  practiceToStudentGradeMetrics: PracticeToStudentGradeMetricArrRelInsertInput
  practiceYieldExpectedOutput: PracticeYieldExpectedOutputObjRelInsertInput
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PracticeYieldGradeMetricMaxFields {
  createdAt: timestamptz
  expectedYieldId: uuid
  id: uuid
  name: String
  points: Int
  updatedAt: timestamptz
}

"""
order by max() on columns of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricMaxOrderBy {
  createdAt: OrderBy
  expectedYieldId: OrderBy
  id: OrderBy
  name: OrderBy
  points: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PracticeYieldGradeMetricMinFields {
  createdAt: timestamptz
  expectedYieldId: uuid
  id: uuid
  name: String
  points: Int
  updatedAt: timestamptz
}

"""
order by min() on columns of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricMinOrderBy {
  createdAt: OrderBy
  expectedYieldId: OrderBy
  id: OrderBy
  name: OrderBy
  points: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "practice_yield_grade_metric"
"""
type PracticeYieldGradeMetricMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeYieldGradeMetric!]!
}

"""
input type for inserting object relation for remote table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricObjRelInsertInput {
  data: PracticeYieldGradeMetricInsertInput!

  """upsert condition"""
  onConflict: PracticeYieldGradeMetricOnConflict
}

"""
on_conflict condition type for table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricOnConflict {
  constraint: PracticeYieldGradeMetricConstraint!
  updateColumns: [PracticeYieldGradeMetricUpdateColumn!]! = []
  where: PracticeYieldGradeMetricBoolExp
}

"""
Ordering options when selecting data from "practice_yield_grade_metric".
"""
input PracticeYieldGradeMetricOrderBy {
  createdAt: OrderBy
  expectedYieldId: OrderBy
  feedbacks: OrderBy
  id: OrderBy
  name: OrderBy
  points: OrderBy
  practiceToStudentGradeMetricsAggregate: PracticeToStudentGradeMetricAggregateOrderBy
  practiceYieldExpectedOutput: PracticeYieldExpectedOutputOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: practice_yield_grade_metric"""
input PracticeYieldGradeMetricPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input PracticeYieldGradeMetricPrependInput {
  feedbacks: jsonb
}

"""
select columns of table "practice_yield_grade_metric"
"""
enum PracticeYieldGradeMetricSelectColumn {
  """column name"""
  createdAt

  """column name"""
  expectedYieldId

  """column name"""
  feedbacks

  """column name"""
  id

  """column name"""
  name

  """column name"""
  points

  """column name"""
  updatedAt
}

"""
input type for updating data in table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricSetInput {
  createdAt: timestamptz
  expectedYieldId: uuid
  feedbacks: jsonb
  id: uuid
  name: String
  points: Int
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type PracticeYieldGradeMetricStddevFields {
  points: Float
}

"""
order by stddev() on columns of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricStddevOrderBy {
  points: OrderBy
}

"""aggregate stddevPop on columns"""
type PracticeYieldGradeMetricStddevPopFields {
  points: Float
}

"""
order by stddevPop() on columns of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricStddevPopOrderBy {
  points: OrderBy
}

"""aggregate stddevSamp on columns"""
type PracticeYieldGradeMetricStddevSampFields {
  points: Float
}

"""
order by stddevSamp() on columns of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricStddevSampOrderBy {
  points: OrderBy
}

"""
Streaming cursor of the table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeYieldGradeMetricStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeYieldGradeMetricStreamCursorValueInput {
  createdAt: timestamptz
  expectedYieldId: uuid
  feedbacks: jsonb
  id: uuid
  name: String
  points: Int
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type PracticeYieldGradeMetricSumFields {
  points: Int
}

"""
order by sum() on columns of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricSumOrderBy {
  points: OrderBy
}

"""
update columns of table "practice_yield_grade_metric"
"""
enum PracticeYieldGradeMetricUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  expectedYieldId

  """column name"""
  feedbacks

  """column name"""
  id

  """column name"""
  name

  """column name"""
  points

  """column name"""
  updatedAt
}

input PracticeYieldGradeMetricUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: PracticeYieldGradeMetricAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: PracticeYieldGradeMetricDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: PracticeYieldGradeMetricDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: PracticeYieldGradeMetricDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: PracticeYieldGradeMetricIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: PracticeYieldGradeMetricPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: PracticeYieldGradeMetricSetInput

  """filter the rows which have to be updated"""
  where: PracticeYieldGradeMetricBoolExp!
}

"""aggregate varPop on columns"""
type PracticeYieldGradeMetricVarPopFields {
  points: Float
}

"""
order by varPop() on columns of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricVarPopOrderBy {
  points: OrderBy
}

"""aggregate varSamp on columns"""
type PracticeYieldGradeMetricVarSampFields {
  points: Float
}

"""
order by varSamp() on columns of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricVarSampOrderBy {
  points: OrderBy
}

"""aggregate variance on columns"""
type PracticeYieldGradeMetricVarianceFields {
  points: Float
}

"""
order by variance() on columns of table "practice_yield_grade_metric"
"""
input PracticeYieldGradeMetricVarianceOrderBy {
  points: OrderBy
}

"""
input type for inserting data into table "practice_yield"
"""
input PracticeYieldInsertInput {
  createdAt: timestamptz
  description: String
  id: uuid
  meta: jsonb
  method: String
  name: String
  practice: PracticeObjRelInsertInput
  practiceId: uuid
  practiceToStudentYields: PracticeToStudentYieldArrRelInsertInput
  practiceYieldExpectedOutputs: PracticeYieldExpectedOutputArrRelInsertInput
  practiceYieldType: PracticeYieldTypeObjRelInsertInput
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PracticeYieldMaxFields {
  createdAt: timestamptz
  description: String
  id: uuid
  method: String
  name: String
  practiceId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "practice_yield"
"""
input PracticeYieldMaxOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  method: OrderBy
  name: OrderBy
  practiceId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PracticeYieldMinFields {
  createdAt: timestamptz
  description: String
  id: uuid
  method: String
  name: String
  practiceId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "practice_yield"
"""
input PracticeYieldMinOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  method: OrderBy
  name: OrderBy
  practiceId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "practice_yield"
"""
type PracticeYieldMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeYield!]!
}

"""
input type for inserting object relation for remote table "practice_yield"
"""
input PracticeYieldObjRelInsertInput {
  data: PracticeYieldInsertInput!

  """upsert condition"""
  onConflict: PracticeYieldOnConflict
}

"""
on_conflict condition type for table "practice_yield"
"""
input PracticeYieldOnConflict {
  constraint: PracticeYieldConstraint!
  updateColumns: [PracticeYieldUpdateColumn!]! = []
  where: PracticeYieldBoolExp
}

"""Ordering options when selecting data from "practice_yield"."""
input PracticeYieldOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  meta: OrderBy
  method: OrderBy
  name: OrderBy
  practice: PracticeOrderBy
  practiceId: OrderBy
  practiceToStudentYieldsAggregate: PracticeToStudentYieldAggregateOrderBy
  practiceYieldExpectedOutputsAggregate: PracticeYieldExpectedOutputAggregateOrderBy
  practiceYieldType: PracticeYieldTypeOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: practice_yield"""
input PracticeYieldPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input PracticeYieldPrependInput {
  meta: jsonb
}

"""
select columns of table "practice_yield"
"""
enum PracticeYieldSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  meta

  """column name"""
  method

  """column name"""
  name

  """column name"""
  practiceId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "practice_yield"
"""
input PracticeYieldSetInput {
  createdAt: timestamptz
  description: String
  id: uuid
  meta: jsonb
  method: String
  name: String
  practiceId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "practice_yield"
"""
input PracticeYieldStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeYieldStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeYieldStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  id: uuid
  meta: jsonb
  method: String
  name: String
  practiceId: uuid
  updatedAt: timestamptz
}

"""
columns and relationships of "practice_yield_type"
"""
type PracticeYieldType {
  name: String!

  """An array relationship"""
  practiceYields(
    """distinct select on columns"""
    distinctOn: [PracticeYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldBoolExp
  ): [PracticeYield!]!

  """An aggregate relationship"""
  practiceYieldsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldBoolExp
  ): PracticeYieldAggregate!
}

"""
aggregated selection of "practice_yield_type"
"""
type PracticeYieldTypeAggregate {
  aggregate: PracticeYieldTypeAggregateFields
  nodes: [PracticeYieldType!]!
}

"""
aggregate fields of "practice_yield_type"
"""
type PracticeYieldTypeAggregateFields {
  count(columns: [PracticeYieldTypeSelectColumn!], distinct: Boolean): Int!
  max: PracticeYieldTypeMaxFields
  min: PracticeYieldTypeMinFields
}

"""
Boolean expression to filter rows from the table "practice_yield_type". All fields are combined with a logical 'AND'.
"""
input PracticeYieldTypeBoolExp {
  _and: [PracticeYieldTypeBoolExp!]
  _not: PracticeYieldTypeBoolExp
  _or: [PracticeYieldTypeBoolExp!]
  name: StringComparisonExp
  practiceYields: PracticeYieldBoolExp
  practiceYieldsAggregate: PracticeYieldAggregateBoolExp
}

"""
unique or primary key constraints on table "practice_yield_type"
"""
enum PracticeYieldTypeConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  practice_yield_type_pkey
}

"""
input type for inserting data into table "practice_yield_type"
"""
input PracticeYieldTypeInsertInput {
  name: String
  practiceYields: PracticeYieldArrRelInsertInput
}

"""aggregate max on columns"""
type PracticeYieldTypeMaxFields {
  name: String
}

"""aggregate min on columns"""
type PracticeYieldTypeMinFields {
  name: String
}

"""
response of any mutation on the table "practice_yield_type"
"""
type PracticeYieldTypeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PracticeYieldType!]!
}

"""
input type for inserting object relation for remote table "practice_yield_type"
"""
input PracticeYieldTypeObjRelInsertInput {
  data: PracticeYieldTypeInsertInput!

  """upsert condition"""
  onConflict: PracticeYieldTypeOnConflict
}

"""
on_conflict condition type for table "practice_yield_type"
"""
input PracticeYieldTypeOnConflict {
  constraint: PracticeYieldTypeConstraint!
  updateColumns: [PracticeYieldTypeUpdateColumn!]! = []
  where: PracticeYieldTypeBoolExp
}

"""Ordering options when selecting data from "practice_yield_type"."""
input PracticeYieldTypeOrderBy {
  name: OrderBy
  practiceYieldsAggregate: PracticeYieldAggregateOrderBy
}

"""primary key columns input for table: practice_yield_type"""
input PracticeYieldTypePkColumnsInput {
  name: String!
}

"""
select columns of table "practice_yield_type"
"""
enum PracticeYieldTypeSelectColumn {
  """column name"""
  name
}

"""
input type for updating data in table "practice_yield_type"
"""
input PracticeYieldTypeSetInput {
  name: String
}

"""
Streaming cursor of the table "practice_yield_type"
"""
input PracticeYieldTypeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PracticeYieldTypeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PracticeYieldTypeStreamCursorValueInput {
  name: String
}

"""
update columns of table "practice_yield_type"
"""
enum PracticeYieldTypeUpdateColumn {
  """column name"""
  name
}

input PracticeYieldTypeUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PracticeYieldTypeSetInput

  """filter the rows which have to be updated"""
  where: PracticeYieldTypeBoolExp!
}

"""
update columns of table "practice_yield"
"""
enum PracticeYieldUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  meta

  """column name"""
  method

  """column name"""
  name

  """column name"""
  practiceId

  """column name"""
  updatedAt
}

input PracticeYieldUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: PracticeYieldAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: PracticeYieldDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: PracticeYieldDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: PracticeYieldDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: PracticeYieldPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: PracticeYieldSetInput

  """filter the rows which have to be updated"""
  where: PracticeYieldBoolExp!
}

type RefreshGradesOutput {
  affected_rows: Int!
}

"""
columns and relationships of "roles"
"""
type Roles {
  """An array relationship"""
  allowedRoles(
    """distinct select on columns"""
    distinctOn: [AllowedRolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AllowedRolesOrderBy!]

    """filter the rows returned"""
    where: AllowedRolesBoolExp
  ): [AllowedRoles!]!

  """An aggregate relationship"""
  allowedRolesAggregate(
    """distinct select on columns"""
    distinctOn: [AllowedRolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AllowedRolesOrderBy!]

    """filter the rows returned"""
    where: AllowedRolesBoolExp
  ): AllowedRolesAggregate!
  description: String

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """An aggregate relationship"""
  usersAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!
  value: String!
}

"""
aggregated selection of "roles"
"""
type RolesAggregate {
  aggregate: RolesAggregateFields
  nodes: [Roles!]!
}

"""
aggregate fields of "roles"
"""
type RolesAggregateFields {
  count(columns: [RolesSelectColumn!], distinct: Boolean): Int!
  max: RolesMaxFields
  min: RolesMinFields
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input RolesBoolExp {
  _and: [RolesBoolExp!]
  _not: RolesBoolExp
  _or: [RolesBoolExp!]
  allowedRoles: AllowedRolesBoolExp
  allowedRolesAggregate: AllowedRolesAggregateBoolExp
  description: StringComparisonExp
  users: UserBoolExp
  usersAggregate: UserAggregateBoolExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "roles"
"""
enum RolesConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  roles_pkey
}

"""
input type for inserting data into table "roles"
"""
input RolesInsertInput {
  allowedRoles: AllowedRolesArrRelInsertInput
  description: String
  users: UserArrRelInsertInput
  value: String
}

"""aggregate max on columns"""
type RolesMaxFields {
  description: String
  value: String
}

"""aggregate min on columns"""
type RolesMinFields {
  description: String
  value: String
}

"""
response of any mutation on the table "roles"
"""
type RolesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input RolesObjRelInsertInput {
  data: RolesInsertInput!

  """upsert condition"""
  onConflict: RolesOnConflict
}

"""
on_conflict condition type for table "roles"
"""
input RolesOnConflict {
  constraint: RolesConstraint!
  updateColumns: [RolesUpdateColumn!]! = []
  where: RolesBoolExp
}

"""Ordering options when selecting data from "roles"."""
input RolesOrderBy {
  allowedRolesAggregate: AllowedRolesAggregateOrderBy
  description: OrderBy
  usersAggregate: UserAggregateOrderBy
  value: OrderBy
}

"""primary key columns input for table: roles"""
input RolesPkColumnsInput {
  value: String!
}

"""
select columns of table "roles"
"""
enum RolesSelectColumn {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "roles"
"""
input RolesSetInput {
  description: String
  value: String
}

"""
Streaming cursor of the table "roles"
"""
input RolesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RolesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RolesStreamCursorValueInput {
  description: String
  value: String
}

"""
update columns of table "roles"
"""
enum RolesUpdateColumn {
  """column name"""
  description

  """column name"""
  value
}

input RolesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: RolesSetInput

  """filter the rows which have to be updated"""
  where: RolesBoolExp!
}

type SendStudentClaimMailOutput {
  nmbMailSent: Int!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "student"
"""
type Student {
  claimToken: uuid
  createdAt: timestamptz!
  email: String
  firstName: String
  full_name: String
  id: uuid!
  lastName: String

  """An array relationship"""
  practiceToStudents(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentBoolExp
  ): [PracticeToStudent!]!

  """An aggregate relationship"""
  practiceToStudentsAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentBoolExp
  ): PracticeToStudentAggregate!

  """An array relationship"""
  studentToCourses(
    """distinct select on columns"""
    distinctOn: [StudentToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentToCourseOrderBy!]

    """filter the rows returned"""
    where: StudentToCourseBoolExp
  ): [StudentToCourse!]!

  """An aggregate relationship"""
  studentToCoursesAggregate(
    """distinct select on columns"""
    distinctOn: [StudentToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentToCourseOrderBy!]

    """filter the rows returned"""
    where: StudentToCourseBoolExp
  ): StudentToCourseAggregate!
  updatedAt: timestamptz!

  """An object relationship"""
  user: User
  userId: uuid
}

"""
aggregated selection of "student"
"""
type StudentAggregate {
  aggregate: StudentAggregateFields
  nodes: [Student!]!
}

"""
aggregate fields of "student"
"""
type StudentAggregateFields {
  count(columns: [StudentSelectColumn!], distinct: Boolean): Int!
  max: StudentMaxFields
  min: StudentMinFields
}

"""
Boolean expression to filter rows from the table "student". All fields are combined with a logical 'AND'.
"""
input StudentBoolExp {
  _and: [StudentBoolExp!]
  _not: StudentBoolExp
  _or: [StudentBoolExp!]
  claimToken: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  email: StringComparisonExp
  firstName: StringComparisonExp
  full_name: StringComparisonExp
  id: UuidComparisonExp
  lastName: StringComparisonExp
  practiceToStudents: PracticeToStudentBoolExp
  practiceToStudentsAggregate: PracticeToStudentAggregateBoolExp
  studentToCourses: StudentToCourseBoolExp
  studentToCoursesAggregate: StudentToCourseAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "student"
"""
enum StudentConstraint {
  """
  unique or primary key constraint on columns "claim_token"
  """
  student_claim_token_key

  """
  unique or primary key constraint on columns "email"
  """
  student_email_key

  """
  unique or primary key constraint on columns "id"
  """
  student_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  student_user_id_key
}

"""
input type for inserting data into table "student"
"""
input StudentInsertInput {
  claimToken: uuid
  createdAt: timestamptz
  email: String
  firstName: String
  id: uuid
  lastName: String
  practiceToStudents: PracticeToStudentArrRelInsertInput
  studentToCourses: StudentToCourseArrRelInsertInput
  updatedAt: timestamptz
  user: UserObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type StudentMaxFields {
  claimToken: uuid
  createdAt: timestamptz
  email: String
  firstName: String
  full_name: String
  id: uuid
  lastName: String
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate min on columns"""
type StudentMinFields {
  claimToken: uuid
  createdAt: timestamptz
  email: String
  firstName: String
  full_name: String
  id: uuid
  lastName: String
  updatedAt: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "student"
"""
type StudentMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Student!]!
}

"""
input type for inserting object relation for remote table "student"
"""
input StudentObjRelInsertInput {
  data: StudentInsertInput!

  """upsert condition"""
  onConflict: StudentOnConflict
}

"""
on_conflict condition type for table "student"
"""
input StudentOnConflict {
  constraint: StudentConstraint!
  updateColumns: [StudentUpdateColumn!]! = []
  where: StudentBoolExp
}

"""Ordering options when selecting data from "student"."""
input StudentOrderBy {
  claimToken: OrderBy
  createdAt: OrderBy
  email: OrderBy
  firstName: OrderBy
  full_name: OrderBy
  id: OrderBy
  lastName: OrderBy
  practiceToStudentsAggregate: PracticeToStudentAggregateOrderBy
  studentToCoursesAggregate: StudentToCourseAggregateOrderBy
  updatedAt: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

"""primary key columns input for table: student"""
input StudentPkColumnsInput {
  id: uuid!
}

"""
select columns of table "student"
"""
enum StudentSelectColumn {
  """column name"""
  claimToken

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  firstName

  """column name"""
  id

  """column name"""
  lastName

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "student"
"""
input StudentSetInput {
  claimToken: uuid
  createdAt: timestamptz
  email: String
  firstName: String
  id: uuid
  lastName: String
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "student"
"""
input StudentStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: StudentStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input StudentStreamCursorValueInput {
  claimToken: uuid
  createdAt: timestamptz
  email: String
  firstName: String
  id: uuid
  lastName: String
  updatedAt: timestamptz
  userId: uuid
}

"""
columns and relationships of "student_to_course"
"""
type StudentToCourse {
  """An object relationship"""
  course: Course!
  courseId: uuid!
  createdAt: timestamptz!

  """An object relationship"""
  student: Student!
  studentId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "student_to_course"
"""
type StudentToCourseAggregate {
  aggregate: StudentToCourseAggregateFields
  nodes: [StudentToCourse!]!
}

input StudentToCourseAggregateBoolExp {
  count: studentToCourseAggregateBoolExpCount
}

"""
aggregate fields of "student_to_course"
"""
type StudentToCourseAggregateFields {
  count(columns: [StudentToCourseSelectColumn!], distinct: Boolean): Int!
  max: StudentToCourseMaxFields
  min: StudentToCourseMinFields
}

"""
order by aggregate values of table "student_to_course"
"""
input StudentToCourseAggregateOrderBy {
  count: OrderBy
  max: StudentToCourseMaxOrderBy
  min: StudentToCourseMinOrderBy
}

"""
input type for inserting array relation for remote table "student_to_course"
"""
input StudentToCourseArrRelInsertInput {
  data: [StudentToCourseInsertInput!]!

  """upsert condition"""
  onConflict: StudentToCourseOnConflict
}

"""
Boolean expression to filter rows from the table "student_to_course". All fields are combined with a logical 'AND'.
"""
input StudentToCourseBoolExp {
  _and: [StudentToCourseBoolExp!]
  _not: StudentToCourseBoolExp
  _or: [StudentToCourseBoolExp!]
  course: CourseBoolExp
  courseId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  student: StudentBoolExp
  studentId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "student_to_course"
"""
enum StudentToCourseConstraint {
  """
  unique or primary key constraint on columns "course_id", "student_id"
  """
  student_to_promotion_pkey

  """
  unique or primary key constraint on columns "course_id", "student_id"
  """
  student_to_promotion_promotion_id_student_id_key
}

"""
input type for inserting data into table "student_to_course"
"""
input StudentToCourseInsertInput {
  course: CourseObjRelInsertInput
  courseId: uuid
  createdAt: timestamptz
  student: StudentObjRelInsertInput
  studentId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type StudentToCourseMaxFields {
  courseId: uuid
  createdAt: timestamptz
  studentId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "student_to_course"
"""
input StudentToCourseMaxOrderBy {
  courseId: OrderBy
  createdAt: OrderBy
  studentId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type StudentToCourseMinFields {
  courseId: uuid
  createdAt: timestamptz
  studentId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "student_to_course"
"""
input StudentToCourseMinOrderBy {
  courseId: OrderBy
  createdAt: OrderBy
  studentId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "student_to_course"
"""
type StudentToCourseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [StudentToCourse!]!
}

"""
on_conflict condition type for table "student_to_course"
"""
input StudentToCourseOnConflict {
  constraint: StudentToCourseConstraint!
  updateColumns: [StudentToCourseUpdateColumn!]! = []
  where: StudentToCourseBoolExp
}

"""Ordering options when selecting data from "student_to_course"."""
input StudentToCourseOrderBy {
  course: CourseOrderBy
  courseId: OrderBy
  createdAt: OrderBy
  student: StudentOrderBy
  studentId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: student_to_course"""
input StudentToCoursePkColumnsInput {
  courseId: uuid!
  studentId: uuid!
}

"""
select columns of table "student_to_course"
"""
enum StudentToCourseSelectColumn {
  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  studentId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "student_to_course"
"""
input StudentToCourseSetInput {
  courseId: uuid
  createdAt: timestamptz
  studentId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "student_to_course"
"""
input StudentToCourseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: StudentToCourseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input StudentToCourseStreamCursorValueInput {
  courseId: uuid
  createdAt: timestamptz
  studentId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "student_to_course"
"""
enum StudentToCourseUpdateColumn {
  """column name"""
  courseId

  """column name"""
  createdAt

  """column name"""
  studentId

  """column name"""
  updatedAt
}

input StudentToCourseUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: StudentToCourseSetInput

  """filter the rows which have to be updated"""
  where: StudentToCourseBoolExp!
}

"""
update columns of table "student"
"""
enum StudentUpdateColumn {
  """column name"""
  claimToken

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  firstName

  """column name"""
  id

  """column name"""
  lastName

  """column name"""
  updatedAt

  """column name"""
  userId
}

input StudentUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: StudentSetInput

  """filter the rows which have to be updated"""
  where: StudentBoolExp!
}

type SubmitHandoffOutput {
  status: String!
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user"
"""
type User {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinctOn: [AccountsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountsOrderBy!]

    """filter the rows returned"""
    where: AccountsBoolExp
  ): [Accounts!]!

  """An aggregate relationship"""
  accountsAggregate(
    """distinct select on columns"""
    distinctOn: [AccountsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountsOrderBy!]

    """filter the rows returned"""
    where: AccountsBoolExp
  ): AccountsAggregate!

  """An array relationship"""
  allowedRoles(
    """distinct select on columns"""
    distinctOn: [AllowedRolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AllowedRolesOrderBy!]

    """filter the rows returned"""
    where: AllowedRolesBoolExp
  ): [AllowedRoles!]!

  """An aggregate relationship"""
  allowedRolesAggregate(
    """distinct select on columns"""
    distinctOn: [AllowedRolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AllowedRolesOrderBy!]

    """filter the rows returned"""
    where: AllowedRolesBoolExp
  ): AllowedRolesAggregate!
  createdAt: timestamptz!
  defaultRole: String!
  email: String!
  emailVerified: timestamptz
  id: uuid!
  image: String
  name: String

  """An object relationship"""
  role: Roles!

  """An object relationship"""
  student: Student
  updatedAt: timestamptz!
}

"""
aggregated selection of "user"
"""
type UserAggregate {
  aggregate: UserAggregateFields
  nodes: [User!]!
}

input UserAggregateBoolExp {
  count: userAggregateBoolExpCount
}

"""
aggregate fields of "user"
"""
type UserAggregateFields {
  count(columns: [UserSelectColumn!], distinct: Boolean): Int!
  max: UserMaxFields
  min: UserMinFields
}

"""
order by aggregate values of table "user"
"""
input UserAggregateOrderBy {
  count: OrderBy
  max: UserMaxOrderBy
  min: UserMinOrderBy
}

"""
input type for inserting array relation for remote table "user"
"""
input UserArrRelInsertInput {
  data: [UserInsertInput!]!

  """upsert condition"""
  onConflict: UserOnConflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input UserBoolExp {
  _and: [UserBoolExp!]
  _not: UserBoolExp
  _or: [UserBoolExp!]
  accounts: AccountsBoolExp
  accountsAggregate: AccountsAggregateBoolExp
  allowedRoles: AllowedRolesBoolExp
  allowedRolesAggregate: AllowedRolesAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  defaultRole: StringComparisonExp
  email: StringComparisonExp
  emailVerified: TimestamptzComparisonExp
  id: UuidComparisonExp
  image: StringComparisonExp
  name: StringComparisonExp
  role: RolesBoolExp
  student: StudentBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "user"
"""
enum UserConstraint {
  """
  unique or primary key constraint on columns "email"
  """
  user_email_key

  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}

"""
input type for inserting data into table "user"
"""
input UserInsertInput {
  accounts: AccountsArrRelInsertInput
  allowedRoles: AllowedRolesArrRelInsertInput
  createdAt: timestamptz
  defaultRole: String
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  role: RolesObjRelInsertInput
  student: StudentObjRelInsertInput
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type UserMaxFields {
  createdAt: timestamptz
  defaultRole: String
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "user"
"""
input UserMaxOrderBy {
  createdAt: OrderBy
  defaultRole: OrderBy
  email: OrderBy
  emailVerified: OrderBy
  id: OrderBy
  image: OrderBy
  name: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type UserMinFields {
  createdAt: timestamptz
  defaultRole: String
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "user"
"""
input UserMinOrderBy {
  createdAt: OrderBy
  defaultRole: OrderBy
  email: OrderBy
  emailVerified: OrderBy
  id: OrderBy
  image: OrderBy
  name: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "user"
"""
type UserMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [User!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input UserObjRelInsertInput {
  data: UserInsertInput!

  """upsert condition"""
  onConflict: UserOnConflict
}

"""
on_conflict condition type for table "user"
"""
input UserOnConflict {
  constraint: UserConstraint!
  updateColumns: [UserUpdateColumn!]! = []
  where: UserBoolExp
}

"""Ordering options when selecting data from "user"."""
input UserOrderBy {
  accountsAggregate: AccountsAggregateOrderBy
  allowedRolesAggregate: AllowedRolesAggregateOrderBy
  createdAt: OrderBy
  defaultRole: OrderBy
  email: OrderBy
  emailVerified: OrderBy
  id: OrderBy
  image: OrderBy
  name: OrderBy
  role: RolesOrderBy
  student: StudentOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: user"""
input UserPkColumnsInput {
  id: uuid!
}

"""
select columns of table "user"
"""
enum UserSelectColumn {
  """column name"""
  createdAt

  """column name"""
  defaultRole

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  updatedAt
}

"""
input type for updating data in table "user"
"""
input UserSetInput {
  createdAt: timestamptz
  defaultRole: String
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "user"
"""
input UserStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserStreamCursorValueInput {
  createdAt: timestamptz
  defaultRole: String
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  updatedAt: timestamptz
}

"""
update columns of table "user"
"""
enum UserUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  defaultRole

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  updatedAt
}

input UserUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserSetInput

  """filter the rows which have to be updated"""
  where: UserBoolExp!
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "verification_requests"
"""
type VerificationRequests {
  createdAt: timestamptz!
  expires: timestamptz
  id: uuid!
  identifier: String!
  token: String!
  updatedAt: timestamptz!
  url: String
}

"""
aggregated selection of "verification_requests"
"""
type VerificationRequestsAggregate {
  aggregate: VerificationRequestsAggregateFields
  nodes: [VerificationRequests!]!
}

"""
aggregate fields of "verification_requests"
"""
type VerificationRequestsAggregateFields {
  count(columns: [VerificationRequestsSelectColumn!], distinct: Boolean): Int!
  max: VerificationRequestsMaxFields
  min: VerificationRequestsMinFields
}

"""
Boolean expression to filter rows from the table "verification_requests". All fields are combined with a logical 'AND'.
"""
input VerificationRequestsBoolExp {
  _and: [VerificationRequestsBoolExp!]
  _not: VerificationRequestsBoolExp
  _or: [VerificationRequestsBoolExp!]
  createdAt: TimestamptzComparisonExp
  expires: TimestamptzComparisonExp
  id: UuidComparisonExp
  identifier: StringComparisonExp
  token: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  url: StringComparisonExp
}

"""
unique or primary key constraints on table "verification_requests"
"""
enum VerificationRequestsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  verification_requests_pkey

  """
  unique or primary key constraint on columns "token"
  """
  verification_requests_token_key
}

"""
input type for inserting data into table "verification_requests"
"""
input VerificationRequestsInsertInput {
  createdAt: timestamptz
  expires: timestamptz
  id: uuid
  identifier: String
  token: String
  updatedAt: timestamptz
  url: String
}

"""aggregate max on columns"""
type VerificationRequestsMaxFields {
  createdAt: timestamptz
  expires: timestamptz
  id: uuid
  identifier: String
  token: String
  updatedAt: timestamptz
  url: String
}

"""aggregate min on columns"""
type VerificationRequestsMinFields {
  createdAt: timestamptz
  expires: timestamptz
  id: uuid
  identifier: String
  token: String
  updatedAt: timestamptz
  url: String
}

"""
response of any mutation on the table "verification_requests"
"""
type VerificationRequestsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [VerificationRequests!]!
}

"""
on_conflict condition type for table "verification_requests"
"""
input VerificationRequestsOnConflict {
  constraint: VerificationRequestsConstraint!
  updateColumns: [VerificationRequestsUpdateColumn!]! = []
  where: VerificationRequestsBoolExp
}

"""Ordering options when selecting data from "verification_requests"."""
input VerificationRequestsOrderBy {
  createdAt: OrderBy
  expires: OrderBy
  id: OrderBy
  identifier: OrderBy
  token: OrderBy
  updatedAt: OrderBy
  url: OrderBy
}

"""primary key columns input for table: verification_requests"""
input VerificationRequestsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "verification_requests"
"""
enum VerificationRequestsSelectColumn {
  """column name"""
  createdAt

  """column name"""
  expires

  """column name"""
  id

  """column name"""
  identifier

  """column name"""
  token

  """column name"""
  updatedAt

  """column name"""
  url
}

"""
input type for updating data in table "verification_requests"
"""
input VerificationRequestsSetInput {
  createdAt: timestamptz
  expires: timestamptz
  id: uuid
  identifier: String
  token: String
  updatedAt: timestamptz
  url: String
}

"""
Streaming cursor of the table "verification_requests"
"""
input VerificationRequestsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: VerificationRequestsStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input VerificationRequestsStreamCursorValueInput {
  createdAt: timestamptz
  expires: timestamptz
  id: uuid
  identifier: String
  token: String
  updatedAt: timestamptz
  url: String
}

"""
update columns of table "verification_requests"
"""
enum VerificationRequestsUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  expires

  """column name"""
  id

  """column name"""
  identifier

  """column name"""
  token

  """column name"""
  updatedAt

  """column name"""
  url
}

input VerificationRequestsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: VerificationRequestsSetInput

  """filter the rows which have to be updated"""
  where: VerificationRequestsBoolExp!
}

input YieldForHandoff {
  value: String!
  yieldId: uuid!
}

input accountsAggregateBoolExpCount {
  arguments: [AccountsSelectColumn!]
  distinct: Boolean
  filter: AccountsBoolExp
  predicate: IntComparisonExp!
}

input allowedRolesAggregateBoolExpCount {
  arguments: [AllowedRolesSelectColumn!]
  distinct: Boolean
  filter: AllowedRolesBoolExp
  predicate: IntComparisonExp!
}

scalar float8

scalar jsonb

type linkStudentToUserOutput {
  ok: Boolean!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "accounts"
  """
  deleteAccounts(
    """filter the rows which have to be deleted"""
    where: AccountsBoolExp!
  ): AccountsMutationResponse

  """
  delete single row from the table: "accounts"
  """
  deleteAccountsByPk(id: uuid!): Accounts

  """
  delete data from the table: "allowed_roles"
  """
  deleteAllowedRoles(
    """filter the rows which have to be deleted"""
    where: AllowedRolesBoolExp!
  ): AllowedRolesMutationResponse

  """
  delete single row from the table: "allowed_roles"
  """
  deleteAllowedRolesByPk(role: String!, userId: uuid!): AllowedRoles

  """
  delete data from the table: "course"
  """
  deleteCourse(
    """filter the rows which have to be deleted"""
    where: CourseBoolExp!
  ): CourseMutationResponse

  """
  delete single row from the table: "course"
  """
  deleteCourseByPk(id: uuid!): Course

  """
  delete data from the table: "practice"
  """
  deletePractice(
    """filter the rows which have to be deleted"""
    where: PracticeBoolExp!
  ): PracticeMutationResponse

  """
  delete single row from the table: "practice"
  """
  deletePracticeByPk(id: uuid!): Practice

  """
  delete data from the table: "practice_to_course"
  """
  deletePracticeToCourse(
    """filter the rows which have to be deleted"""
    where: PracticeToCourseBoolExp!
  ): PracticeToCourseMutationResponse

  """
  delete single row from the table: "practice_to_course"
  """
  deletePracticeToCourseByPk(id: uuid!): PracticeToCourse

  """
  delete data from the table: "practice_to_student"
  """
  deletePracticeToStudent(
    """filter the rows which have to be deleted"""
    where: PracticeToStudentBoolExp!
  ): PracticeToStudentMutationResponse

  """
  delete single row from the table: "practice_to_student"
  """
  deletePracticeToStudentByPk(id: uuid!): PracticeToStudent

  """
  delete data from the table: "practice_to_student_feedback"
  """
  deletePracticeToStudentFeedback(
    """filter the rows which have to be deleted"""
    where: PracticeToStudentFeedbackBoolExp!
  ): PracticeToStudentFeedbackMutationResponse

  """
  delete data from the table: "practice_to_student_grade"
  """
  deletePracticeToStudentGrade(
    """filter the rows which have to be deleted"""
    where: PracticeToStudentGradeBoolExp!
  ): PracticeToStudentGradeMutationResponse

  """
  delete data from the table: "practice_to_student_grade_metric"
  """
  deletePracticeToStudentGradeMetric(
    """filter the rows which have to be deleted"""
    where: PracticeToStudentGradeMetricBoolExp!
  ): PracticeToStudentGradeMetricMutationResponse

  """
  delete single row from the table: "practice_to_student_grade_metric"
  """
  deletePracticeToStudentGradeMetricByPk(id: uuid!): PracticeToStudentGradeMetric

  """
  delete data from the table: "practice_to_student_yield"
  """
  deletePracticeToStudentYield(
    """filter the rows which have to be deleted"""
    where: PracticeToStudentYieldBoolExp!
  ): PracticeToStudentYieldMutationResponse

  """
  delete single row from the table: "practice_to_student_yield"
  """
  deletePracticeToStudentYieldByPk(id: uuid!): PracticeToStudentYield

  """
  delete data from the table: "practice_yield"
  """
  deletePracticeYield(
    """filter the rows which have to be deleted"""
    where: PracticeYieldBoolExp!
  ): PracticeYieldMutationResponse

  """
  delete single row from the table: "practice_yield"
  """
  deletePracticeYieldByPk(id: uuid!): PracticeYield

  """
  delete data from the table: "practice_yield_expected_output"
  """
  deletePracticeYieldExpectedOutput(
    """filter the rows which have to be deleted"""
    where: PracticeYieldExpectedOutputBoolExp!
  ): PracticeYieldExpectedOutputMutationResponse

  """
  delete single row from the table: "practice_yield_expected_output"
  """
  deletePracticeYieldExpectedOutputByPk(id: uuid!): PracticeYieldExpectedOutput

  """
  delete data from the table: "practice_yield_expected_output_types"
  """
  deletePracticeYieldExpectedOutputTypes(
    """filter the rows which have to be deleted"""
    where: PracticeYieldExpectedOutputTypesBoolExp!
  ): PracticeYieldExpectedOutputTypesMutationResponse

  """
  delete single row from the table: "practice_yield_expected_output_types"
  """
  deletePracticeYieldExpectedOutputTypesByPk(name: String!): PracticeYieldExpectedOutputTypes

  """
  delete data from the table: "practice_yield_grade_metric"
  """
  deletePracticeYieldGradeMetric(
    """filter the rows which have to be deleted"""
    where: PracticeYieldGradeMetricBoolExp!
  ): PracticeYieldGradeMetricMutationResponse

  """
  delete single row from the table: "practice_yield_grade_metric"
  """
  deletePracticeYieldGradeMetricByPk(id: uuid!): PracticeYieldGradeMetric

  """
  delete data from the table: "practice_yield_type"
  """
  deletePracticeYieldType(
    """filter the rows which have to be deleted"""
    where: PracticeYieldTypeBoolExp!
  ): PracticeYieldTypeMutationResponse

  """
  delete single row from the table: "practice_yield_type"
  """
  deletePracticeYieldTypeByPk(name: String!): PracticeYieldType

  """
  delete data from the table: "roles"
  """
  deleteRoles(
    """filter the rows which have to be deleted"""
    where: RolesBoolExp!
  ): RolesMutationResponse

  """
  delete single row from the table: "roles"
  """
  deleteRolesByPk(value: String!): Roles

  """
  delete data from the table: "student"
  """
  deleteStudent(
    """filter the rows which have to be deleted"""
    where: StudentBoolExp!
  ): StudentMutationResponse

  """
  delete single row from the table: "student"
  """
  deleteStudentByPk(id: uuid!): Student

  """
  delete data from the table: "student_to_course"
  """
  deleteStudentToCourse(
    """filter the rows which have to be deleted"""
    where: StudentToCourseBoolExp!
  ): StudentToCourseMutationResponse

  """
  delete single row from the table: "student_to_course"
  """
  deleteStudentToCourseByPk(courseId: uuid!, studentId: uuid!): StudentToCourse

  """
  delete data from the table: "user"
  """
  deleteUser(
    """filter the rows which have to be deleted"""
    where: UserBoolExp!
  ): UserMutationResponse

  """
  delete single row from the table: "user"
  """
  deleteUserByPk(id: uuid!): User

  """
  delete data from the table: "verification_requests"
  """
  deleteVerificationRequests(
    """filter the rows which have to be deleted"""
    where: VerificationRequestsBoolExp!
  ): VerificationRequestsMutationResponse

  """
  delete single row from the table: "verification_requests"
  """
  deleteVerificationRequestsByPk(id: uuid!): VerificationRequests
  fillEmptyYields(course_id: uuid!, practice_id: uuid!): FillEmptyYieldsOutput

  """
  insert data into the table: "accounts"
  """
  insertAccounts(
    """the rows to be inserted"""
    objects: [AccountsInsertInput!]!

    """upsert condition"""
    onConflict: AccountsOnConflict
  ): AccountsMutationResponse

  """
  insert a single row into the table: "accounts"
  """
  insertAccountsOne(
    """the row to be inserted"""
    object: AccountsInsertInput!

    """upsert condition"""
    onConflict: AccountsOnConflict
  ): Accounts

  """
  insert data into the table: "allowed_roles"
  """
  insertAllowedRoles(
    """the rows to be inserted"""
    objects: [AllowedRolesInsertInput!]!

    """upsert condition"""
    onConflict: AllowedRolesOnConflict
  ): AllowedRolesMutationResponse

  """
  insert a single row into the table: "allowed_roles"
  """
  insertAllowedRolesOne(
    """the row to be inserted"""
    object: AllowedRolesInsertInput!

    """upsert condition"""
    onConflict: AllowedRolesOnConflict
  ): AllowedRoles

  """
  insert data into the table: "course"
  """
  insertCourse(
    """the rows to be inserted"""
    objects: [CourseInsertInput!]!

    """upsert condition"""
    onConflict: CourseOnConflict
  ): CourseMutationResponse

  """
  insert a single row into the table: "course"
  """
  insertCourseOne(
    """the row to be inserted"""
    object: CourseInsertInput!

    """upsert condition"""
    onConflict: CourseOnConflict
  ): Course

  """
  insert data into the table: "practice"
  """
  insertPractice(
    """the rows to be inserted"""
    objects: [PracticeInsertInput!]!

    """upsert condition"""
    onConflict: PracticeOnConflict
  ): PracticeMutationResponse

  """
  insert a single row into the table: "practice"
  """
  insertPracticeOne(
    """the row to be inserted"""
    object: PracticeInsertInput!

    """upsert condition"""
    onConflict: PracticeOnConflict
  ): Practice

  """
  insert data into the table: "practice_to_course"
  """
  insertPracticeToCourse(
    """the rows to be inserted"""
    objects: [PracticeToCourseInsertInput!]!

    """upsert condition"""
    onConflict: PracticeToCourseOnConflict
  ): PracticeToCourseMutationResponse

  """
  insert a single row into the table: "practice_to_course"
  """
  insertPracticeToCourseOne(
    """the row to be inserted"""
    object: PracticeToCourseInsertInput!

    """upsert condition"""
    onConflict: PracticeToCourseOnConflict
  ): PracticeToCourse

  """
  insert data into the table: "practice_to_student"
  """
  insertPracticeToStudent(
    """the rows to be inserted"""
    objects: [PracticeToStudentInsertInput!]!

    """upsert condition"""
    onConflict: PracticeToStudentOnConflict
  ): PracticeToStudentMutationResponse

  """
  insert data into the table: "practice_to_student_feedback"
  """
  insertPracticeToStudentFeedback(
    """the rows to be inserted"""
    objects: [PracticeToStudentFeedbackInsertInput!]!
  ): PracticeToStudentFeedbackMutationResponse

  """
  insert a single row into the table: "practice_to_student_feedback"
  """
  insertPracticeToStudentFeedbackOne(
    """the row to be inserted"""
    object: PracticeToStudentFeedbackInsertInput!
  ): PracticeToStudentFeedback

  """
  insert data into the table: "practice_to_student_grade"
  """
  insertPracticeToStudentGrade(
    """the rows to be inserted"""
    objects: [PracticeToStudentGradeInsertInput!]!
  ): PracticeToStudentGradeMutationResponse

  """
  insert data into the table: "practice_to_student_grade_metric"
  """
  insertPracticeToStudentGradeMetric(
    """the rows to be inserted"""
    objects: [PracticeToStudentGradeMetricInsertInput!]!

    """upsert condition"""
    onConflict: PracticeToStudentGradeMetricOnConflict
  ): PracticeToStudentGradeMetricMutationResponse

  """
  insert a single row into the table: "practice_to_student_grade_metric"
  """
  insertPracticeToStudentGradeMetricOne(
    """the row to be inserted"""
    object: PracticeToStudentGradeMetricInsertInput!

    """upsert condition"""
    onConflict: PracticeToStudentGradeMetricOnConflict
  ): PracticeToStudentGradeMetric

  """
  insert a single row into the table: "practice_to_student_grade"
  """
  insertPracticeToStudentGradeOne(
    """the row to be inserted"""
    object: PracticeToStudentGradeInsertInput!
  ): PracticeToStudentGrade

  """
  insert a single row into the table: "practice_to_student"
  """
  insertPracticeToStudentOne(
    """the row to be inserted"""
    object: PracticeToStudentInsertInput!

    """upsert condition"""
    onConflict: PracticeToStudentOnConflict
  ): PracticeToStudent

  """
  insert data into the table: "practice_to_student_yield"
  """
  insertPracticeToStudentYield(
    """the rows to be inserted"""
    objects: [PracticeToStudentYieldInsertInput!]!

    """upsert condition"""
    onConflict: PracticeToStudentYieldOnConflict
  ): PracticeToStudentYieldMutationResponse

  """
  insert a single row into the table: "practice_to_student_yield"
  """
  insertPracticeToStudentYieldOne(
    """the row to be inserted"""
    object: PracticeToStudentYieldInsertInput!

    """upsert condition"""
    onConflict: PracticeToStudentYieldOnConflict
  ): PracticeToStudentYield

  """
  insert data into the table: "practice_yield"
  """
  insertPracticeYield(
    """the rows to be inserted"""
    objects: [PracticeYieldInsertInput!]!

    """upsert condition"""
    onConflict: PracticeYieldOnConflict
  ): PracticeYieldMutationResponse

  """
  insert data into the table: "practice_yield_expected_output"
  """
  insertPracticeYieldExpectedOutput(
    """the rows to be inserted"""
    objects: [PracticeYieldExpectedOutputInsertInput!]!

    """upsert condition"""
    onConflict: PracticeYieldExpectedOutputOnConflict
  ): PracticeYieldExpectedOutputMutationResponse

  """
  insert a single row into the table: "practice_yield_expected_output"
  """
  insertPracticeYieldExpectedOutputOne(
    """the row to be inserted"""
    object: PracticeYieldExpectedOutputInsertInput!

    """upsert condition"""
    onConflict: PracticeYieldExpectedOutputOnConflict
  ): PracticeYieldExpectedOutput

  """
  insert data into the table: "practice_yield_expected_output_types"
  """
  insertPracticeYieldExpectedOutputTypes(
    """the rows to be inserted"""
    objects: [PracticeYieldExpectedOutputTypesInsertInput!]!

    """upsert condition"""
    onConflict: PracticeYieldExpectedOutputTypesOnConflict
  ): PracticeYieldExpectedOutputTypesMutationResponse

  """
  insert a single row into the table: "practice_yield_expected_output_types"
  """
  insertPracticeYieldExpectedOutputTypesOne(
    """the row to be inserted"""
    object: PracticeYieldExpectedOutputTypesInsertInput!

    """upsert condition"""
    onConflict: PracticeYieldExpectedOutputTypesOnConflict
  ): PracticeYieldExpectedOutputTypes

  """
  insert data into the table: "practice_yield_grade_metric"
  """
  insertPracticeYieldGradeMetric(
    """the rows to be inserted"""
    objects: [PracticeYieldGradeMetricInsertInput!]!

    """upsert condition"""
    onConflict: PracticeYieldGradeMetricOnConflict
  ): PracticeYieldGradeMetricMutationResponse

  """
  insert a single row into the table: "practice_yield_grade_metric"
  """
  insertPracticeYieldGradeMetricOne(
    """the row to be inserted"""
    object: PracticeYieldGradeMetricInsertInput!

    """upsert condition"""
    onConflict: PracticeYieldGradeMetricOnConflict
  ): PracticeYieldGradeMetric

  """
  insert a single row into the table: "practice_yield"
  """
  insertPracticeYieldOne(
    """the row to be inserted"""
    object: PracticeYieldInsertInput!

    """upsert condition"""
    onConflict: PracticeYieldOnConflict
  ): PracticeYield

  """
  insert data into the table: "practice_yield_type"
  """
  insertPracticeYieldType(
    """the rows to be inserted"""
    objects: [PracticeYieldTypeInsertInput!]!

    """upsert condition"""
    onConflict: PracticeYieldTypeOnConflict
  ): PracticeYieldTypeMutationResponse

  """
  insert a single row into the table: "practice_yield_type"
  """
  insertPracticeYieldTypeOne(
    """the row to be inserted"""
    object: PracticeYieldTypeInsertInput!

    """upsert condition"""
    onConflict: PracticeYieldTypeOnConflict
  ): PracticeYieldType

  """
  insert data into the table: "roles"
  """
  insertRoles(
    """the rows to be inserted"""
    objects: [RolesInsertInput!]!

    """upsert condition"""
    onConflict: RolesOnConflict
  ): RolesMutationResponse

  """
  insert a single row into the table: "roles"
  """
  insertRolesOne(
    """the row to be inserted"""
    object: RolesInsertInput!

    """upsert condition"""
    onConflict: RolesOnConflict
  ): Roles

  """
  insert data into the table: "student"
  """
  insertStudent(
    """the rows to be inserted"""
    objects: [StudentInsertInput!]!

    """upsert condition"""
    onConflict: StudentOnConflict
  ): StudentMutationResponse

  """
  insert a single row into the table: "student"
  """
  insertStudentOne(
    """the row to be inserted"""
    object: StudentInsertInput!

    """upsert condition"""
    onConflict: StudentOnConflict
  ): Student

  """
  insert data into the table: "student_to_course"
  """
  insertStudentToCourse(
    """the rows to be inserted"""
    objects: [StudentToCourseInsertInput!]!

    """upsert condition"""
    onConflict: StudentToCourseOnConflict
  ): StudentToCourseMutationResponse

  """
  insert a single row into the table: "student_to_course"
  """
  insertStudentToCourseOne(
    """the row to be inserted"""
    object: StudentToCourseInsertInput!

    """upsert condition"""
    onConflict: StudentToCourseOnConflict
  ): StudentToCourse

  """
  insert data into the table: "user"
  """
  insertUser(
    """the rows to be inserted"""
    objects: [UserInsertInput!]!

    """upsert condition"""
    onConflict: UserOnConflict
  ): UserMutationResponse

  """
  insert a single row into the table: "user"
  """
  insertUserOne(
    """the row to be inserted"""
    object: UserInsertInput!

    """upsert condition"""
    onConflict: UserOnConflict
  ): User

  """
  insert data into the table: "verification_requests"
  """
  insertVerificationRequests(
    """the rows to be inserted"""
    objects: [VerificationRequestsInsertInput!]!

    """upsert condition"""
    onConflict: VerificationRequestsOnConflict
  ): VerificationRequestsMutationResponse

  """
  insert a single row into the table: "verification_requests"
  """
  insertVerificationRequestsOne(
    """the row to be inserted"""
    object: VerificationRequestsInsertInput!

    """upsert condition"""
    onConflict: VerificationRequestsOnConflict
  ): VerificationRequests
  linkStudentToUser(linkId: uuid!): linkStudentToUserOutput
  refreshGrades(course_id: uuid!, practice_id: uuid!): RefreshGradesOutput
  sendStudentClaimMail(studentsIds: [uuid]!): SendStudentClaimMailOutput
  submitHandoff(practiceToPromotionId: uuid!, yields: [YieldForHandoff!]!): SubmitHandoffOutput

  """
  update data of the table: "accounts"
  """
  updateAccounts(
    """sets the columns of the filtered rows to the given values"""
    _set: AccountsSetInput

    """filter the rows which have to be updated"""
    where: AccountsBoolExp!
  ): AccountsMutationResponse

  """
  update single row of the table: "accounts"
  """
  updateAccountsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: AccountsSetInput
    pkColumns: AccountsPkColumnsInput!
  ): Accounts

  """
  update multiples rows of table: "accounts"
  """
  updateAccountsMany(
    """updates to execute, in order"""
    updates: [AccountsUpdates!]!
  ): [AccountsMutationResponse]

  """
  update data of the table: "allowed_roles"
  """
  updateAllowedRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: AllowedRolesSetInput

    """filter the rows which have to be updated"""
    where: AllowedRolesBoolExp!
  ): AllowedRolesMutationResponse

  """
  update single row of the table: "allowed_roles"
  """
  updateAllowedRolesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: AllowedRolesSetInput
    pkColumns: AllowedRolesPkColumnsInput!
  ): AllowedRoles

  """
  update multiples rows of table: "allowed_roles"
  """
  updateAllowedRolesMany(
    """updates to execute, in order"""
    updates: [AllowedRolesUpdates!]!
  ): [AllowedRolesMutationResponse]

  """
  update data of the table: "course"
  """
  updateCourse(
    """sets the columns of the filtered rows to the given values"""
    _set: CourseSetInput

    """filter the rows which have to be updated"""
    where: CourseBoolExp!
  ): CourseMutationResponse

  """
  update single row of the table: "course"
  """
  updateCourseByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: CourseSetInput
    pkColumns: CoursePkColumnsInput!
  ): Course

  """
  update multiples rows of table: "course"
  """
  updateCourseMany(
    """updates to execute, in order"""
    updates: [CourseUpdates!]!
  ): [CourseMutationResponse]

  """
  update data of the table: "practice"
  """
  updatePractice(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeSetInput

    """filter the rows which have to be updated"""
    where: PracticeBoolExp!
  ): PracticeMutationResponse

  """
  update single row of the table: "practice"
  """
  updatePracticeByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeSetInput
    pkColumns: PracticePkColumnsInput!
  ): Practice

  """
  update multiples rows of table: "practice"
  """
  updatePracticeMany(
    """updates to execute, in order"""
    updates: [PracticeUpdates!]!
  ): [PracticeMutationResponse]

  """
  update data of the table: "practice_to_course"
  """
  updatePracticeToCourse(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeToCourseSetInput

    """filter the rows which have to be updated"""
    where: PracticeToCourseBoolExp!
  ): PracticeToCourseMutationResponse

  """
  update single row of the table: "practice_to_course"
  """
  updatePracticeToCourseByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeToCourseSetInput
    pkColumns: PracticeToCoursePkColumnsInput!
  ): PracticeToCourse

  """
  update multiples rows of table: "practice_to_course"
  """
  updatePracticeToCourseMany(
    """updates to execute, in order"""
    updates: [PracticeToCourseUpdates!]!
  ): [PracticeToCourseMutationResponse]

  """
  update data of the table: "practice_to_student"
  """
  updatePracticeToStudent(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PracticeToStudentAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PracticeToStudentDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PracticeToStudentDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PracticeToStudentDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: PracticeToStudentIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PracticeToStudentPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: PracticeToStudentSetInput

    """filter the rows which have to be updated"""
    where: PracticeToStudentBoolExp!
  ): PracticeToStudentMutationResponse

  """
  update single row of the table: "practice_to_student"
  """
  updatePracticeToStudentByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PracticeToStudentAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PracticeToStudentDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PracticeToStudentDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PracticeToStudentDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: PracticeToStudentIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PracticeToStudentPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: PracticeToStudentSetInput
    pkColumns: PracticeToStudentPkColumnsInput!
  ): PracticeToStudent

  """
  update data of the table: "practice_to_student_feedback"
  """
  updatePracticeToStudentFeedback(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PracticeToStudentFeedbackAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PracticeToStudentFeedbackDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PracticeToStudentFeedbackDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PracticeToStudentFeedbackDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PracticeToStudentFeedbackPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: PracticeToStudentFeedbackSetInput

    """filter the rows which have to be updated"""
    where: PracticeToStudentFeedbackBoolExp!
  ): PracticeToStudentFeedbackMutationResponse

  """
  update multiples rows of table: "practice_to_student_feedback"
  """
  updatePracticeToStudentFeedbackMany(
    """updates to execute, in order"""
    updates: [PracticeToStudentFeedbackUpdates!]!
  ): [PracticeToStudentFeedbackMutationResponse]

  """
  update data of the table: "practice_to_student_grade"
  """
  updatePracticeToStudentGrade(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PracticeToStudentGradeAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PracticeToStudentGradeDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PracticeToStudentGradeDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PracticeToStudentGradeDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: PracticeToStudentGradeIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PracticeToStudentGradePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: PracticeToStudentGradeSetInput

    """filter the rows which have to be updated"""
    where: PracticeToStudentGradeBoolExp!
  ): PracticeToStudentGradeMutationResponse

  """
  update multiples rows of table: "practice_to_student_grade"
  """
  updatePracticeToStudentGradeMany(
    """updates to execute, in order"""
    updates: [PracticeToStudentGradeUpdates!]!
  ): [PracticeToStudentGradeMutationResponse]

  """
  update data of the table: "practice_to_student_grade_metric"
  """
  updatePracticeToStudentGradeMetric(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PracticeToStudentGradeMetricAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PracticeToStudentGradeMetricDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PracticeToStudentGradeMetricDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PracticeToStudentGradeMetricDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: PracticeToStudentGradeMetricIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PracticeToStudentGradeMetricPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: PracticeToStudentGradeMetricSetInput

    """filter the rows which have to be updated"""
    where: PracticeToStudentGradeMetricBoolExp!
  ): PracticeToStudentGradeMetricMutationResponse

  """
  update single row of the table: "practice_to_student_grade_metric"
  """
  updatePracticeToStudentGradeMetricByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PracticeToStudentGradeMetricAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PracticeToStudentGradeMetricDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PracticeToStudentGradeMetricDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PracticeToStudentGradeMetricDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: PracticeToStudentGradeMetricIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PracticeToStudentGradeMetricPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: PracticeToStudentGradeMetricSetInput
    pkColumns: PracticeToStudentGradeMetricPkColumnsInput!
  ): PracticeToStudentGradeMetric

  """
  update multiples rows of table: "practice_to_student_grade_metric"
  """
  updatePracticeToStudentGradeMetricMany(
    """updates to execute, in order"""
    updates: [PracticeToStudentGradeMetricUpdates!]!
  ): [PracticeToStudentGradeMetricMutationResponse]

  """
  update multiples rows of table: "practice_to_student"
  """
  updatePracticeToStudentMany(
    """updates to execute, in order"""
    updates: [PracticeToStudentUpdates!]!
  ): [PracticeToStudentMutationResponse]

  """
  update data of the table: "practice_to_student_yield"
  """
  updatePracticeToStudentYield(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeToStudentYieldSetInput

    """filter the rows which have to be updated"""
    where: PracticeToStudentYieldBoolExp!
  ): PracticeToStudentYieldMutationResponse

  """
  update single row of the table: "practice_to_student_yield"
  """
  updatePracticeToStudentYieldByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeToStudentYieldSetInput
    pkColumns: PracticeToStudentYieldPkColumnsInput!
  ): PracticeToStudentYield

  """
  update multiples rows of table: "practice_to_student_yield"
  """
  updatePracticeToStudentYieldMany(
    """updates to execute, in order"""
    updates: [PracticeToStudentYieldUpdates!]!
  ): [PracticeToStudentYieldMutationResponse]

  """
  update data of the table: "practice_yield"
  """
  updatePracticeYield(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PracticeYieldAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PracticeYieldDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PracticeYieldDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PracticeYieldDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PracticeYieldPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: PracticeYieldSetInput

    """filter the rows which have to be updated"""
    where: PracticeYieldBoolExp!
  ): PracticeYieldMutationResponse

  """
  update single row of the table: "practice_yield"
  """
  updatePracticeYieldByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PracticeYieldAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PracticeYieldDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PracticeYieldDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PracticeYieldDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PracticeYieldPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: PracticeYieldSetInput
    pkColumns: PracticeYieldPkColumnsInput!
  ): PracticeYield

  """
  update data of the table: "practice_yield_expected_output"
  """
  updatePracticeYieldExpectedOutput(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeYieldExpectedOutputSetInput

    """filter the rows which have to be updated"""
    where: PracticeYieldExpectedOutputBoolExp!
  ): PracticeYieldExpectedOutputMutationResponse

  """
  update single row of the table: "practice_yield_expected_output"
  """
  updatePracticeYieldExpectedOutputByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeYieldExpectedOutputSetInput
    pkColumns: PracticeYieldExpectedOutputPkColumnsInput!
  ): PracticeYieldExpectedOutput

  """
  update multiples rows of table: "practice_yield_expected_output"
  """
  updatePracticeYieldExpectedOutputMany(
    """updates to execute, in order"""
    updates: [PracticeYieldExpectedOutputUpdates!]!
  ): [PracticeYieldExpectedOutputMutationResponse]

  """
  update data of the table: "practice_yield_expected_output_types"
  """
  updatePracticeYieldExpectedOutputTypes(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeYieldExpectedOutputTypesSetInput

    """filter the rows which have to be updated"""
    where: PracticeYieldExpectedOutputTypesBoolExp!
  ): PracticeYieldExpectedOutputTypesMutationResponse

  """
  update single row of the table: "practice_yield_expected_output_types"
  """
  updatePracticeYieldExpectedOutputTypesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeYieldExpectedOutputTypesSetInput
    pkColumns: PracticeYieldExpectedOutputTypesPkColumnsInput!
  ): PracticeYieldExpectedOutputTypes

  """
  update multiples rows of table: "practice_yield_expected_output_types"
  """
  updatePracticeYieldExpectedOutputTypesMany(
    """updates to execute, in order"""
    updates: [PracticeYieldExpectedOutputTypesUpdates!]!
  ): [PracticeYieldExpectedOutputTypesMutationResponse]

  """
  update data of the table: "practice_yield_grade_metric"
  """
  updatePracticeYieldGradeMetric(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PracticeYieldGradeMetricAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PracticeYieldGradeMetricDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PracticeYieldGradeMetricDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PracticeYieldGradeMetricDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: PracticeYieldGradeMetricIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PracticeYieldGradeMetricPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: PracticeYieldGradeMetricSetInput

    """filter the rows which have to be updated"""
    where: PracticeYieldGradeMetricBoolExp!
  ): PracticeYieldGradeMetricMutationResponse

  """
  update single row of the table: "practice_yield_grade_metric"
  """
  updatePracticeYieldGradeMetricByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PracticeYieldGradeMetricAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PracticeYieldGradeMetricDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PracticeYieldGradeMetricDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PracticeYieldGradeMetricDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: PracticeYieldGradeMetricIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PracticeYieldGradeMetricPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: PracticeYieldGradeMetricSetInput
    pkColumns: PracticeYieldGradeMetricPkColumnsInput!
  ): PracticeYieldGradeMetric

  """
  update multiples rows of table: "practice_yield_grade_metric"
  """
  updatePracticeYieldGradeMetricMany(
    """updates to execute, in order"""
    updates: [PracticeYieldGradeMetricUpdates!]!
  ): [PracticeYieldGradeMetricMutationResponse]

  """
  update multiples rows of table: "practice_yield"
  """
  updatePracticeYieldMany(
    """updates to execute, in order"""
    updates: [PracticeYieldUpdates!]!
  ): [PracticeYieldMutationResponse]

  """
  update data of the table: "practice_yield_type"
  """
  updatePracticeYieldType(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeYieldTypeSetInput

    """filter the rows which have to be updated"""
    where: PracticeYieldTypeBoolExp!
  ): PracticeYieldTypeMutationResponse

  """
  update single row of the table: "practice_yield_type"
  """
  updatePracticeYieldTypeByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PracticeYieldTypeSetInput
    pkColumns: PracticeYieldTypePkColumnsInput!
  ): PracticeYieldType

  """
  update multiples rows of table: "practice_yield_type"
  """
  updatePracticeYieldTypeMany(
    """updates to execute, in order"""
    updates: [PracticeYieldTypeUpdates!]!
  ): [PracticeYieldTypeMutationResponse]

  """
  update data of the table: "roles"
  """
  updateRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: RolesSetInput

    """filter the rows which have to be updated"""
    where: RolesBoolExp!
  ): RolesMutationResponse

  """
  update single row of the table: "roles"
  """
  updateRolesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: RolesSetInput
    pkColumns: RolesPkColumnsInput!
  ): Roles

  """
  update multiples rows of table: "roles"
  """
  updateRolesMany(
    """updates to execute, in order"""
    updates: [RolesUpdates!]!
  ): [RolesMutationResponse]

  """
  update data of the table: "student"
  """
  updateStudent(
    """sets the columns of the filtered rows to the given values"""
    _set: StudentSetInput

    """filter the rows which have to be updated"""
    where: StudentBoolExp!
  ): StudentMutationResponse

  """
  update single row of the table: "student"
  """
  updateStudentByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: StudentSetInput
    pkColumns: StudentPkColumnsInput!
  ): Student

  """
  update multiples rows of table: "student"
  """
  updateStudentMany(
    """updates to execute, in order"""
    updates: [StudentUpdates!]!
  ): [StudentMutationResponse]

  """
  update data of the table: "student_to_course"
  """
  updateStudentToCourse(
    """sets the columns of the filtered rows to the given values"""
    _set: StudentToCourseSetInput

    """filter the rows which have to be updated"""
    where: StudentToCourseBoolExp!
  ): StudentToCourseMutationResponse

  """
  update single row of the table: "student_to_course"
  """
  updateStudentToCourseByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: StudentToCourseSetInput
    pkColumns: StudentToCoursePkColumnsInput!
  ): StudentToCourse

  """
  update multiples rows of table: "student_to_course"
  """
  updateStudentToCourseMany(
    """updates to execute, in order"""
    updates: [StudentToCourseUpdates!]!
  ): [StudentToCourseMutationResponse]

  """
  update data of the table: "user"
  """
  updateUser(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSetInput

    """filter the rows which have to be updated"""
    where: UserBoolExp!
  ): UserMutationResponse

  """
  update single row of the table: "user"
  """
  updateUserByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSetInput
    pkColumns: UserPkColumnsInput!
  ): User

  """
  update multiples rows of table: "user"
  """
  updateUserMany(
    """updates to execute, in order"""
    updates: [UserUpdates!]!
  ): [UserMutationResponse]

  """
  update data of the table: "verification_requests"
  """
  updateVerificationRequests(
    """sets the columns of the filtered rows to the given values"""
    _set: VerificationRequestsSetInput

    """filter the rows which have to be updated"""
    where: VerificationRequestsBoolExp!
  ): VerificationRequestsMutationResponse

  """
  update single row of the table: "verification_requests"
  """
  updateVerificationRequestsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: VerificationRequestsSetInput
    pkColumns: VerificationRequestsPkColumnsInput!
  ): VerificationRequests

  """
  update multiples rows of table: "verification_requests"
  """
  updateVerificationRequestsMany(
    """updates to execute, in order"""
    updates: [VerificationRequestsUpdates!]!
  ): [VerificationRequestsMutationResponse]
}

scalar numeric

input practiceToCourseAggregateBoolExpCount {
  arguments: [PracticeToCourseSelectColumn!]
  distinct: Boolean
  filter: PracticeToCourseBoolExp
  predicate: IntComparisonExp!
}

input practiceToStudentAggregateBoolExpAvg {
  arguments: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpAvgArgumentsColumns!
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: Float8ComparisonExp!
}

input practiceToStudentAggregateBoolExpBool_and {
  arguments: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: BooleanComparisonExp!
}

input practiceToStudentAggregateBoolExpBool_or {
  arguments: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: BooleanComparisonExp!
}

input practiceToStudentAggregateBoolExpCorr {
  arguments: practiceToStudentAggregateBoolExpCorrArguments!
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: Float8ComparisonExp!
}

input practiceToStudentAggregateBoolExpCorrArguments {
  X: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpCorrArgumentsColumns!
  Y: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpCorrArgumentsColumns!
}

input practiceToStudentAggregateBoolExpCount {
  arguments: [PracticeToStudentSelectColumn!]
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: IntComparisonExp!
}

input practiceToStudentAggregateBoolExpCovar_samp {
  arguments: practiceToStudentAggregateBoolExpCovar_sampArguments!
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: Float8ComparisonExp!
}

input practiceToStudentAggregateBoolExpCovar_sampArguments {
  X: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpCovar_sampArgumentsColumns!
  Y: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpCovar_sampArgumentsColumns!
}

input practiceToStudentAggregateBoolExpMax {
  arguments: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpMaxArgumentsColumns!
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: Float8ComparisonExp!
}

input practiceToStudentAggregateBoolExpMin {
  arguments: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpMinArgumentsColumns!
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: Float8ComparisonExp!
}

input practiceToStudentAggregateBoolExpStddev_samp {
  arguments: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpStddev_sampArgumentsColumns!
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: Float8ComparisonExp!
}

input practiceToStudentAggregateBoolExpSum {
  arguments: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpSumArgumentsColumns!
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: Float8ComparisonExp!
}

input practiceToStudentAggregateBoolExpVar_samp {
  arguments: PracticeToStudentSelectColumnPracticeToStudentAggregateBoolExpVar_sampArgumentsColumns!
  distinct: Boolean
  filter: PracticeToStudentBoolExp
  predicate: Float8ComparisonExp!
}

input practiceToStudentGradeMetricAggregateBoolExpCount {
  arguments: [PracticeToStudentGradeMetricSelectColumn!]
  distinct: Boolean
  filter: PracticeToStudentGradeMetricBoolExp
  predicate: IntComparisonExp!
}

input practiceToStudentYieldAggregateBoolExpBool_and {
  arguments: PracticeToStudentYieldSelectColumnPracticeToStudentYieldAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PracticeToStudentYieldBoolExp
  predicate: BooleanComparisonExp!
}

input practiceToStudentYieldAggregateBoolExpBool_or {
  arguments: PracticeToStudentYieldSelectColumnPracticeToStudentYieldAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PracticeToStudentYieldBoolExp
  predicate: BooleanComparisonExp!
}

input practiceToStudentYieldAggregateBoolExpCount {
  arguments: [PracticeToStudentYieldSelectColumn!]
  distinct: Boolean
  filter: PracticeToStudentYieldBoolExp
  predicate: IntComparisonExp!
}

input practiceYieldAggregateBoolExpCount {
  arguments: [PracticeYieldSelectColumn!]
  distinct: Boolean
  filter: PracticeYieldBoolExp
  predicate: IntComparisonExp!
}

input practiceYieldExpectedOutputAggregateBoolExpCount {
  arguments: [PracticeYieldExpectedOutputSelectColumn!]
  distinct: Boolean
  filter: PracticeYieldExpectedOutputBoolExp
  predicate: IntComparisonExp!
}

input practiceYieldGradeMetricAggregateBoolExpCount {
  arguments: [PracticeYieldGradeMetricSelectColumn!]
  distinct: Boolean
  filter: PracticeYieldGradeMetricBoolExp
  predicate: IntComparisonExp!
}

type query_root {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinctOn: [AccountsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountsOrderBy!]

    """filter the rows returned"""
    where: AccountsBoolExp
  ): [Accounts!]!

  """An aggregate relationship"""
  accountsAggregate(
    """distinct select on columns"""
    distinctOn: [AccountsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountsOrderBy!]

    """filter the rows returned"""
    where: AccountsBoolExp
  ): AccountsAggregate!

  """fetch data from the table: "accounts" using primary key columns"""
  accountsByPk(id: uuid!): Accounts

  """An array relationship"""
  allowedRoles(
    """distinct select on columns"""
    distinctOn: [AllowedRolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AllowedRolesOrderBy!]

    """filter the rows returned"""
    where: AllowedRolesBoolExp
  ): [AllowedRoles!]!

  """An aggregate relationship"""
  allowedRolesAggregate(
    """distinct select on columns"""
    distinctOn: [AllowedRolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AllowedRolesOrderBy!]

    """filter the rows returned"""
    where: AllowedRolesBoolExp
  ): AllowedRolesAggregate!

  """fetch data from the table: "allowed_roles" using primary key columns"""
  allowedRolesByPk(role: String!, userId: uuid!): AllowedRoles

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  courseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """fetch data from the table: "course" using primary key columns"""
  courseByPk(id: uuid!): Course
  getGitFileData(practice_to_student_yield_id: uuid!, practice_yield_expected_output_id: uuid!): GetGitFileDataOutput
  getGitLogData(practice_to_student_yield_id: uuid!, practice_yield_expected_output_id: uuid!): [CommitItem!]!

  """
  fetch data from the table: "practice"
  """
  practice(
    """distinct select on columns"""
    distinctOn: [PracticeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeOrderBy!]

    """filter the rows returned"""
    where: PracticeBoolExp
  ): [Practice!]!

  """
  fetch aggregated fields from the table: "practice"
  """
  practiceAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeOrderBy!]

    """filter the rows returned"""
    where: PracticeBoolExp
  ): PracticeAggregate!

  """fetch data from the table: "practice" using primary key columns"""
  practiceByPk(id: uuid!): Practice

  """
  fetch data from the table: "practice_to_course"
  """
  practiceToCourse(
    """distinct select on columns"""
    distinctOn: [PracticeToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToCourseOrderBy!]

    """filter the rows returned"""
    where: PracticeToCourseBoolExp
  ): [PracticeToCourse!]!

  """
  fetch aggregated fields from the table: "practice_to_course"
  """
  practiceToCourseAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToCourseOrderBy!]

    """filter the rows returned"""
    where: PracticeToCourseBoolExp
  ): PracticeToCourseAggregate!

  """
  fetch data from the table: "practice_to_course" using primary key columns
  """
  practiceToCourseByPk(id: uuid!): PracticeToCourse

  """
  fetch data from the table: "practice_to_student"
  """
  practiceToStudent(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentBoolExp
  ): [PracticeToStudent!]!

  """
  fetch aggregated fields from the table: "practice_to_student"
  """
  practiceToStudentAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentBoolExp
  ): PracticeToStudentAggregate!

  """
  fetch data from the table: "practice_to_student" using primary key columns
  """
  practiceToStudentByPk(id: uuid!): PracticeToStudent

  """
  fetch data from the table: "practice_to_student_feedback"
  """
  practiceToStudentFeedback(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentFeedbackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentFeedbackOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentFeedbackBoolExp
  ): [PracticeToStudentFeedback!]!

  """
  fetch aggregated fields from the table: "practice_to_student_feedback"
  """
  practiceToStudentFeedbackAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentFeedbackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentFeedbackOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentFeedbackBoolExp
  ): PracticeToStudentFeedbackAggregate!

  """
  fetch data from the table: "practice_to_student_grade"
  """
  practiceToStudentGrade(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeBoolExp
  ): [PracticeToStudentGrade!]!

  """
  fetch aggregated fields from the table: "practice_to_student_grade"
  """
  practiceToStudentGradeAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeBoolExp
  ): PracticeToStudentGradeAggregate!

  """
  fetch data from the table: "practice_to_student_grade_metric"
  """
  practiceToStudentGradeMetric(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeMetricBoolExp
  ): [PracticeToStudentGradeMetric!]!

  """
  fetch aggregated fields from the table: "practice_to_student_grade_metric"
  """
  practiceToStudentGradeMetricAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeMetricBoolExp
  ): PracticeToStudentGradeMetricAggregate!

  """
  fetch data from the table: "practice_to_student_grade_metric" using primary key columns
  """
  practiceToStudentGradeMetricByPk(id: uuid!): PracticeToStudentGradeMetric

  """
  fetch data from the table: "practice_to_student_yield"
  """
  practiceToStudentYield(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentYieldBoolExp
  ): [PracticeToStudentYield!]!

  """
  fetch aggregated fields from the table: "practice_to_student_yield"
  """
  practiceToStudentYieldAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentYieldBoolExp
  ): PracticeToStudentYieldAggregate!

  """
  fetch data from the table: "practice_to_student_yield" using primary key columns
  """
  practiceToStudentYieldByPk(id: uuid!): PracticeToStudentYield

  """
  fetch data from the table: "practice_yield"
  """
  practiceYield(
    """distinct select on columns"""
    distinctOn: [PracticeYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldBoolExp
  ): [PracticeYield!]!

  """
  fetch aggregated fields from the table: "practice_yield"
  """
  practiceYieldAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldBoolExp
  ): PracticeYieldAggregate!

  """fetch data from the table: "practice_yield" using primary key columns"""
  practiceYieldByPk(id: uuid!): PracticeYield

  """
  fetch data from the table: "practice_yield_expected_output"
  """
  practiceYieldExpectedOutput(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputBoolExp
  ): [PracticeYieldExpectedOutput!]!

  """
  fetch aggregated fields from the table: "practice_yield_expected_output"
  """
  practiceYieldExpectedOutputAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputBoolExp
  ): PracticeYieldExpectedOutputAggregate!

  """
  fetch data from the table: "practice_yield_expected_output" using primary key columns
  """
  practiceYieldExpectedOutputByPk(id: uuid!): PracticeYieldExpectedOutput

  """
  fetch data from the table: "practice_yield_expected_output_types"
  """
  practiceYieldExpectedOutputTypes(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputTypesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputTypesOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputTypesBoolExp
  ): [PracticeYieldExpectedOutputTypes!]!

  """
  fetch aggregated fields from the table: "practice_yield_expected_output_types"
  """
  practiceYieldExpectedOutputTypesAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputTypesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputTypesOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputTypesBoolExp
  ): PracticeYieldExpectedOutputTypesAggregate!

  """
  fetch data from the table: "practice_yield_expected_output_types" using primary key columns
  """
  practiceYieldExpectedOutputTypesByPk(name: String!): PracticeYieldExpectedOutputTypes

  """
  fetch data from the table: "practice_yield_grade_metric"
  """
  practiceYieldGradeMetric(
    """distinct select on columns"""
    distinctOn: [PracticeYieldGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldGradeMetricBoolExp
  ): [PracticeYieldGradeMetric!]!

  """
  fetch aggregated fields from the table: "practice_yield_grade_metric"
  """
  practiceYieldGradeMetricAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldGradeMetricBoolExp
  ): PracticeYieldGradeMetricAggregate!

  """
  fetch data from the table: "practice_yield_grade_metric" using primary key columns
  """
  practiceYieldGradeMetricByPk(id: uuid!): PracticeYieldGradeMetric

  """
  fetch data from the table: "practice_yield_type"
  """
  practiceYieldType(
    """distinct select on columns"""
    distinctOn: [PracticeYieldTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldTypeOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldTypeBoolExp
  ): [PracticeYieldType!]!

  """
  fetch aggregated fields from the table: "practice_yield_type"
  """
  practiceYieldTypeAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldTypeOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldTypeBoolExp
  ): PracticeYieldTypeAggregate!

  """
  fetch data from the table: "practice_yield_type" using primary key columns
  """
  practiceYieldTypeByPk(name: String!): PracticeYieldType

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinctOn: [RolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RolesOrderBy!]

    """filter the rows returned"""
    where: RolesBoolExp
  ): [Roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """distinct select on columns"""
    distinctOn: [RolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RolesOrderBy!]

    """filter the rows returned"""
    where: RolesBoolExp
  ): RolesAggregate!

  """fetch data from the table: "roles" using primary key columns"""
  rolesByPk(value: String!): Roles

  """
  fetch data from the table: "student"
  """
  student(
    """distinct select on columns"""
    distinctOn: [StudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentOrderBy!]

    """filter the rows returned"""
    where: StudentBoolExp
  ): [Student!]!

  """
  fetch aggregated fields from the table: "student"
  """
  studentAggregate(
    """distinct select on columns"""
    distinctOn: [StudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentOrderBy!]

    """filter the rows returned"""
    where: StudentBoolExp
  ): StudentAggregate!

  """fetch data from the table: "student" using primary key columns"""
  studentByPk(id: uuid!): Student

  """
  fetch data from the table: "student_to_course"
  """
  studentToCourse(
    """distinct select on columns"""
    distinctOn: [StudentToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentToCourseOrderBy!]

    """filter the rows returned"""
    where: StudentToCourseBoolExp
  ): [StudentToCourse!]!

  """
  fetch aggregated fields from the table: "student_to_course"
  """
  studentToCourseAggregate(
    """distinct select on columns"""
    distinctOn: [StudentToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentToCourseOrderBy!]

    """filter the rows returned"""
    where: StudentToCourseBoolExp
  ): StudentToCourseAggregate!

  """
  fetch data from the table: "student_to_course" using primary key columns
  """
  studentToCourseByPk(courseId: uuid!, studentId: uuid!): StudentToCourse

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!

  """fetch data from the table: "user" using primary key columns"""
  userByPk(id: uuid!): User

  """
  fetch data from the table: "verification_requests"
  """
  verificationRequests(
    """distinct select on columns"""
    distinctOn: [VerificationRequestsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [VerificationRequestsOrderBy!]

    """filter the rows returned"""
    where: VerificationRequestsBoolExp
  ): [VerificationRequests!]!

  """
  fetch aggregated fields from the table: "verification_requests"
  """
  verificationRequestsAggregate(
    """distinct select on columns"""
    distinctOn: [VerificationRequestsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [VerificationRequestsOrderBy!]

    """filter the rows returned"""
    where: VerificationRequestsBoolExp
  ): VerificationRequestsAggregate!

  """
  fetch data from the table: "verification_requests" using primary key columns
  """
  verificationRequestsByPk(id: uuid!): VerificationRequests
}

input studentToCourseAggregateBoolExpCount {
  arguments: [StudentToCourseSelectColumn!]
  distinct: Boolean
  filter: StudentToCourseBoolExp
  predicate: IntComparisonExp!
}

type subscription_root {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinctOn: [AccountsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountsOrderBy!]

    """filter the rows returned"""
    where: AccountsBoolExp
  ): [Accounts!]!

  """An aggregate relationship"""
  accountsAggregate(
    """distinct select on columns"""
    distinctOn: [AccountsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AccountsOrderBy!]

    """filter the rows returned"""
    where: AccountsBoolExp
  ): AccountsAggregate!

  """fetch data from the table: "accounts" using primary key columns"""
  accountsByPk(id: uuid!): Accounts

  """
  fetch data from the table in a streaming manner: "accounts"
  """
  accountsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AccountsStreamCursorInput]!

    """filter the rows returned"""
    where: AccountsBoolExp
  ): [Accounts!]!

  """An array relationship"""
  allowedRoles(
    """distinct select on columns"""
    distinctOn: [AllowedRolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AllowedRolesOrderBy!]

    """filter the rows returned"""
    where: AllowedRolesBoolExp
  ): [AllowedRoles!]!

  """An aggregate relationship"""
  allowedRolesAggregate(
    """distinct select on columns"""
    distinctOn: [AllowedRolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AllowedRolesOrderBy!]

    """filter the rows returned"""
    where: AllowedRolesBoolExp
  ): AllowedRolesAggregate!

  """fetch data from the table: "allowed_roles" using primary key columns"""
  allowedRolesByPk(role: String!, userId: uuid!): AllowedRoles

  """
  fetch data from the table in a streaming manner: "allowed_roles"
  """
  allowedRolesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AllowedRolesStreamCursorInput]!

    """filter the rows returned"""
    where: AllowedRolesBoolExp
  ): [AllowedRoles!]!

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  courseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """fetch data from the table: "course" using primary key columns"""
  courseByPk(id: uuid!): Course

  """
  fetch data from the table in a streaming manner: "course"
  """
  courseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseStreamCursorInput]!

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch data from the table: "practice"
  """
  practice(
    """distinct select on columns"""
    distinctOn: [PracticeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeOrderBy!]

    """filter the rows returned"""
    where: PracticeBoolExp
  ): [Practice!]!

  """
  fetch aggregated fields from the table: "practice"
  """
  practiceAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeOrderBy!]

    """filter the rows returned"""
    where: PracticeBoolExp
  ): PracticeAggregate!

  """fetch data from the table: "practice" using primary key columns"""
  practiceByPk(id: uuid!): Practice

  """
  fetch data from the table in a streaming manner: "practice"
  """
  practiceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeBoolExp
  ): [Practice!]!

  """
  fetch data from the table: "practice_to_course"
  """
  practiceToCourse(
    """distinct select on columns"""
    distinctOn: [PracticeToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToCourseOrderBy!]

    """filter the rows returned"""
    where: PracticeToCourseBoolExp
  ): [PracticeToCourse!]!

  """
  fetch aggregated fields from the table: "practice_to_course"
  """
  practiceToCourseAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToCourseOrderBy!]

    """filter the rows returned"""
    where: PracticeToCourseBoolExp
  ): PracticeToCourseAggregate!

  """
  fetch data from the table: "practice_to_course" using primary key columns
  """
  practiceToCourseByPk(id: uuid!): PracticeToCourse

  """
  fetch data from the table in a streaming manner: "practice_to_course"
  """
  practiceToCourseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeToCourseStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeToCourseBoolExp
  ): [PracticeToCourse!]!

  """
  fetch data from the table: "practice_to_student"
  """
  practiceToStudent(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentBoolExp
  ): [PracticeToStudent!]!

  """
  fetch aggregated fields from the table: "practice_to_student"
  """
  practiceToStudentAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentBoolExp
  ): PracticeToStudentAggregate!

  """
  fetch data from the table: "practice_to_student" using primary key columns
  """
  practiceToStudentByPk(id: uuid!): PracticeToStudent

  """
  fetch data from the table: "practice_to_student_feedback"
  """
  practiceToStudentFeedback(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentFeedbackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentFeedbackOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentFeedbackBoolExp
  ): [PracticeToStudentFeedback!]!

  """
  fetch aggregated fields from the table: "practice_to_student_feedback"
  """
  practiceToStudentFeedbackAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentFeedbackSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentFeedbackOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentFeedbackBoolExp
  ): PracticeToStudentFeedbackAggregate!

  """
  fetch data from the table in a streaming manner: "practice_to_student_feedback"
  """
  practiceToStudentFeedbackStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeToStudentFeedbackStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeToStudentFeedbackBoolExp
  ): [PracticeToStudentFeedback!]!

  """
  fetch data from the table: "practice_to_student_grade"
  """
  practiceToStudentGrade(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeBoolExp
  ): [PracticeToStudentGrade!]!

  """
  fetch aggregated fields from the table: "practice_to_student_grade"
  """
  practiceToStudentGradeAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeBoolExp
  ): PracticeToStudentGradeAggregate!

  """
  fetch data from the table: "practice_to_student_grade_metric"
  """
  practiceToStudentGradeMetric(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeMetricBoolExp
  ): [PracticeToStudentGradeMetric!]!

  """
  fetch aggregated fields from the table: "practice_to_student_grade_metric"
  """
  practiceToStudentGradeMetricAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentGradeMetricBoolExp
  ): PracticeToStudentGradeMetricAggregate!

  """
  fetch data from the table: "practice_to_student_grade_metric" using primary key columns
  """
  practiceToStudentGradeMetricByPk(id: uuid!): PracticeToStudentGradeMetric

  """
  fetch data from the table in a streaming manner: "practice_to_student_grade_metric"
  """
  practiceToStudentGradeMetricStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeToStudentGradeMetricStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeToStudentGradeMetricBoolExp
  ): [PracticeToStudentGradeMetric!]!

  """
  fetch data from the table in a streaming manner: "practice_to_student_grade"
  """
  practiceToStudentGradeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeToStudentGradeStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeToStudentGradeBoolExp
  ): [PracticeToStudentGrade!]!

  """
  fetch data from the table in a streaming manner: "practice_to_student"
  """
  practiceToStudentStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeToStudentStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeToStudentBoolExp
  ): [PracticeToStudent!]!

  """
  fetch data from the table: "practice_to_student_yield"
  """
  practiceToStudentYield(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentYieldBoolExp
  ): [PracticeToStudentYield!]!

  """
  fetch aggregated fields from the table: "practice_to_student_yield"
  """
  practiceToStudentYieldAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeToStudentYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeToStudentYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeToStudentYieldBoolExp
  ): PracticeToStudentYieldAggregate!

  """
  fetch data from the table: "practice_to_student_yield" using primary key columns
  """
  practiceToStudentYieldByPk(id: uuid!): PracticeToStudentYield

  """
  fetch data from the table in a streaming manner: "practice_to_student_yield"
  """
  practiceToStudentYieldStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeToStudentYieldStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeToStudentYieldBoolExp
  ): [PracticeToStudentYield!]!

  """
  fetch data from the table: "practice_yield"
  """
  practiceYield(
    """distinct select on columns"""
    distinctOn: [PracticeYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldBoolExp
  ): [PracticeYield!]!

  """
  fetch aggregated fields from the table: "practice_yield"
  """
  practiceYieldAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldBoolExp
  ): PracticeYieldAggregate!

  """fetch data from the table: "practice_yield" using primary key columns"""
  practiceYieldByPk(id: uuid!): PracticeYield

  """
  fetch data from the table: "practice_yield_expected_output"
  """
  practiceYieldExpectedOutput(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputBoolExp
  ): [PracticeYieldExpectedOutput!]!

  """
  fetch aggregated fields from the table: "practice_yield_expected_output"
  """
  practiceYieldExpectedOutputAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputBoolExp
  ): PracticeYieldExpectedOutputAggregate!

  """
  fetch data from the table: "practice_yield_expected_output" using primary key columns
  """
  practiceYieldExpectedOutputByPk(id: uuid!): PracticeYieldExpectedOutput

  """
  fetch data from the table in a streaming manner: "practice_yield_expected_output"
  """
  practiceYieldExpectedOutputStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeYieldExpectedOutputStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputBoolExp
  ): [PracticeYieldExpectedOutput!]!

  """
  fetch data from the table: "practice_yield_expected_output_types"
  """
  practiceYieldExpectedOutputTypes(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputTypesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputTypesOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputTypesBoolExp
  ): [PracticeYieldExpectedOutputTypes!]!

  """
  fetch aggregated fields from the table: "practice_yield_expected_output_types"
  """
  practiceYieldExpectedOutputTypesAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldExpectedOutputTypesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldExpectedOutputTypesOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputTypesBoolExp
  ): PracticeYieldExpectedOutputTypesAggregate!

  """
  fetch data from the table: "practice_yield_expected_output_types" using primary key columns
  """
  practiceYieldExpectedOutputTypesByPk(name: String!): PracticeYieldExpectedOutputTypes

  """
  fetch data from the table in a streaming manner: "practice_yield_expected_output_types"
  """
  practiceYieldExpectedOutputTypesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeYieldExpectedOutputTypesStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeYieldExpectedOutputTypesBoolExp
  ): [PracticeYieldExpectedOutputTypes!]!

  """
  fetch data from the table: "practice_yield_grade_metric"
  """
  practiceYieldGradeMetric(
    """distinct select on columns"""
    distinctOn: [PracticeYieldGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldGradeMetricBoolExp
  ): [PracticeYieldGradeMetric!]!

  """
  fetch aggregated fields from the table: "practice_yield_grade_metric"
  """
  practiceYieldGradeMetricAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldGradeMetricSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldGradeMetricOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldGradeMetricBoolExp
  ): PracticeYieldGradeMetricAggregate!

  """
  fetch data from the table: "practice_yield_grade_metric" using primary key columns
  """
  practiceYieldGradeMetricByPk(id: uuid!): PracticeYieldGradeMetric

  """
  fetch data from the table in a streaming manner: "practice_yield_grade_metric"
  """
  practiceYieldGradeMetricStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeYieldGradeMetricStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeYieldGradeMetricBoolExp
  ): [PracticeYieldGradeMetric!]!

  """
  fetch data from the table in a streaming manner: "practice_yield"
  """
  practiceYieldStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeYieldStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeYieldBoolExp
  ): [PracticeYield!]!

  """
  fetch data from the table: "practice_yield_type"
  """
  practiceYieldType(
    """distinct select on columns"""
    distinctOn: [PracticeYieldTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldTypeOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldTypeBoolExp
  ): [PracticeYieldType!]!

  """
  fetch aggregated fields from the table: "practice_yield_type"
  """
  practiceYieldTypeAggregate(
    """distinct select on columns"""
    distinctOn: [PracticeYieldTypeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PracticeYieldTypeOrderBy!]

    """filter the rows returned"""
    where: PracticeYieldTypeBoolExp
  ): PracticeYieldTypeAggregate!

  """
  fetch data from the table: "practice_yield_type" using primary key columns
  """
  practiceYieldTypeByPk(name: String!): PracticeYieldType

  """
  fetch data from the table in a streaming manner: "practice_yield_type"
  """
  practiceYieldTypeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PracticeYieldTypeStreamCursorInput]!

    """filter the rows returned"""
    where: PracticeYieldTypeBoolExp
  ): [PracticeYieldType!]!

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinctOn: [RolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RolesOrderBy!]

    """filter the rows returned"""
    where: RolesBoolExp
  ): [Roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """distinct select on columns"""
    distinctOn: [RolesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RolesOrderBy!]

    """filter the rows returned"""
    where: RolesBoolExp
  ): RolesAggregate!

  """fetch data from the table: "roles" using primary key columns"""
  rolesByPk(value: String!): Roles

  """
  fetch data from the table in a streaming manner: "roles"
  """
  rolesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [RolesStreamCursorInput]!

    """filter the rows returned"""
    where: RolesBoolExp
  ): [Roles!]!

  """
  fetch data from the table: "student"
  """
  student(
    """distinct select on columns"""
    distinctOn: [StudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentOrderBy!]

    """filter the rows returned"""
    where: StudentBoolExp
  ): [Student!]!

  """
  fetch aggregated fields from the table: "student"
  """
  studentAggregate(
    """distinct select on columns"""
    distinctOn: [StudentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentOrderBy!]

    """filter the rows returned"""
    where: StudentBoolExp
  ): StudentAggregate!

  """fetch data from the table: "student" using primary key columns"""
  studentByPk(id: uuid!): Student

  """
  fetch data from the table in a streaming manner: "student"
  """
  studentStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [StudentStreamCursorInput]!

    """filter the rows returned"""
    where: StudentBoolExp
  ): [Student!]!

  """
  fetch data from the table: "student_to_course"
  """
  studentToCourse(
    """distinct select on columns"""
    distinctOn: [StudentToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentToCourseOrderBy!]

    """filter the rows returned"""
    where: StudentToCourseBoolExp
  ): [StudentToCourse!]!

  """
  fetch aggregated fields from the table: "student_to_course"
  """
  studentToCourseAggregate(
    """distinct select on columns"""
    distinctOn: [StudentToCourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [StudentToCourseOrderBy!]

    """filter the rows returned"""
    where: StudentToCourseBoolExp
  ): StudentToCourseAggregate!

  """
  fetch data from the table: "student_to_course" using primary key columns
  """
  studentToCourseByPk(courseId: uuid!, studentId: uuid!): StudentToCourse

  """
  fetch data from the table in a streaming manner: "student_to_course"
  """
  studentToCourseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [StudentToCourseStreamCursorInput]!

    """filter the rows returned"""
    where: StudentToCourseBoolExp
  ): [StudentToCourse!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    """distinct select on columns"""
    distinctOn: [UserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserOrderBy!]

    """filter the rows returned"""
    where: UserBoolExp
  ): UserAggregate!

  """fetch data from the table: "user" using primary key columns"""
  userByPk(id: uuid!): User

  """
  fetch data from the table in a streaming manner: "user"
  """
  userStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserStreamCursorInput]!

    """filter the rows returned"""
    where: UserBoolExp
  ): [User!]!

  """
  fetch data from the table: "verification_requests"
  """
  verificationRequests(
    """distinct select on columns"""
    distinctOn: [VerificationRequestsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [VerificationRequestsOrderBy!]

    """filter the rows returned"""
    where: VerificationRequestsBoolExp
  ): [VerificationRequests!]!

  """
  fetch aggregated fields from the table: "verification_requests"
  """
  verificationRequestsAggregate(
    """distinct select on columns"""
    distinctOn: [VerificationRequestsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [VerificationRequestsOrderBy!]

    """filter the rows returned"""
    where: VerificationRequestsBoolExp
  ): VerificationRequestsAggregate!

  """
  fetch data from the table: "verification_requests" using primary key columns
  """
  verificationRequestsByPk(id: uuid!): VerificationRequests

  """
  fetch data from the table in a streaming manner: "verification_requests"
  """
  verificationRequestsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [VerificationRequestsStreamCursorInput]!

    """filter the rows returned"""
    where: VerificationRequestsBoolExp
  ): [VerificationRequests!]!
}

scalar timestamptz

input userAggregateBoolExpCount {
  arguments: [UserSelectColumn!]
  distinct: Boolean
  filter: UserBoolExp
  predicate: IntComparisonExp!
}

scalar uuid